{
  "name": "My workflow",
  "nodes": [
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1663435215,
          "mode": "list",
          "cachedResultName": "Copy of Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=1663435215"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        -896,
        1024
      ],
      "id": "fa72c7b1-777f-4569-a138-24a97ddd4bd5",
      "name": "Get Document URL4",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "documentURL": "={{ $json[\"Document ID\"] }}"
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        -288,
        1008
      ],
      "id": "2cfbe6bb-151d-4e56-a337-91cbaa1a61f5",
      "name": "Get document4",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Structured Output (final form for sheet/db ingest)\n// - Reads a control item with highestIdNum/nextIdNum and url/URL\n// - Assigns Ids (UC{n}), sets References=controlUrl, normalizes Other_References\n// - Adds Timestamp in IST; outputs only use-case rows\nconst toStr = v => (v == null ? \"\" : String(v));\nconst normalizeRefs = v => Array.isArray(v)\n  ? v.map(x => toStr(x).trim()).filter(Boolean).join(\"; \")\n  : toStr(v).trim();\n\nconst getIST = () => {\n  const ist = new Date(Date.now() + 5.5 * 3600 * 1000);\n  const y = ist.getUTCFullYear();\n  const m = String(ist.getUTCMonth() + 1).padStart(2, \"0\");\n  const d = String(ist.getUTCDate()).padStart(2, \"0\");\n  const hh = String(ist.getUTCHours()).padStart(2, \"0\");\n  const mm = String(ist.getUTCMinutes()).padStart(2, \"0\");\n  const ss = String(ist.getUTCSeconds()).padStart(2, \"0\");\n  return `'${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n};\n\n// Identify control item\nlet highestIdNum = 0;\nlet controlUrl = \"\";\nfor (const it of $items()) {\n  const j = it.json || {};\n  if (j.highestIdNum != null || j.nextIdNum != null || j.url != null || j.URL != null) {\n    const n = parseInt(j.highestIdNum ?? j.nextIdNum ?? \"0\", 10);\n    highestIdNum = Number.isNaN(n) ? 0 : n;\n    controlUrl = (toStr(j.url ?? j.URL) || \"\").trim();\n    break;\n  }\n}\n\nconst prefix = \"UC\";\nlet counter = highestIdNum + 1;\n\n// Collect only use case items (exclude control)\nconst data = $items()\n  .map(it => it.json)\n  .filter(j => j && j.Industry && j.Title_Of_AI_Use_Case && !(\"highestIdNum\" in j) && !(\"nextIdNum\" in j));\n\nconst out = data.map(u => {\n  const otherRefsNormalized = normalizeRefs(\n    u.Other_References ?? u.OtherReferences ?? u[\"Other References\"] ?? u.References ?? \"\"\n  ) || controlUrl;\n\n  return {\n    json: {\n      Id: `${prefix}${counter++}`,\n      Industry: toStr(u.Industry),\n      Subindustry: toStr(u.Subindustry),\n      Business_Function: toStr(u.Business_Function),\n      Business_Capability: toStr(u.Business_Capability),\n      Stakeholder_Or_User: toStr(u.Stakeholder_Or_User),\n      Companies_Involved: toStr(u.Companies_Involved ?? \"\"),\n      Title_Of_AI_Use_Case: toStr(u.Title_Of_AI_Use_Case),\n      Description: toStr(u.Description),\n      Impact: toStr(u.Impact),\n      Action_Implementation_Plan: toStr(u.Action_Implementation_Plan),\n      Expected_Outcomes_And_Results: toStr(u.Expected_Outcomes_And_Results),\n      Datasets: toStr(u.Datasets),\n      AI_Capabilities_And_Tech: toStr(u.AI_Capabilities_And_Tech),\n      Digital_Platforms_And_Tools_And_Models: toStr(u.Digital_Platforms_And_Tools_And_Models),\n      AI_Algo_And_Frameworks: toStr(u.AI_Algo_And_Frameworks),\n      References: controlUrl,\n      Other_References: otherRefsNormalized,\n      Timestamp: getIST()\n    }\n  };\n});\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        656,
        1280
      ],
      "id": "df4c71ad-505b-4611-b68f-d52e205690d9",
      "name": "Structured Output4",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k",
          "mode": "list",
          "cachedResultName": "AI_Use_cases_Perplexity",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 495948948,
          "mode": "list",
          "cachedResultName": "Perplexity LLM Generated Output Data_v2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit#gid=495948948"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Id": "={{ $json.Id }}",
            "Industry": "={{ $json.Industry }}",
            "Subindustry": "={{ $json.Subindustry }}",
            "Business_Function": "={{ $json.Business_Function }}",
            "Business_Capability": "={{ $json.Business_Capability }}",
            "Stakeholder_Or_User": "={{ $json.Stakeholder_Or_User }}",
            "Description": "={{ $json.Description }}",
            "Impact": "={{ $json.Impact }}",
            "Action_Implementation_Plan": "={{ $json.Action_Implementation_Plan }}",
            "Expected_Outcomes_And_Results": "={{ $json.Expected_Outcomes_And_Results }}",
            "Datasets": "={{ $json.Datasets }}",
            "Timestamp": "={{ $json.Timestamp }}",
            "References": "={{ $json.References }}",
            "AI_Algo_And_Frameworks": "={{ $json.AI_Algo_And_Frameworks }}",
            "AI_Capabilities_And_Tech": "={{ $json.AI_Capabilities_And_Tech }}",
            "Title_Of_AI_Use_Case": "={{ $json.Title_Of_AI_Use_Case }}",
            "Other_References": "={{ $json.Other_References }}",
            "Digital_Platforms_And_Tools_And_Models": "={{ $json.Digital_Platforms_And_Tools_And_Models }}"
          },
          "matchingColumns": [
            "Id"
          ],
          "schema": [
            {
              "id": "Id",
              "displayName": "Id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Industry",
              "displayName": "Industry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Subindustry",
              "displayName": "Subindustry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Business_Function",
              "displayName": "Business_Function",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Business_Capability",
              "displayName": "Business_Capability",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Stakeholder_Or_User",
              "displayName": "Stakeholder_Or_User",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Title_Of_AI_Use_Case",
              "displayName": "Title_Of_AI_Use_Case",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Description",
              "displayName": "Description",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Impact",
              "displayName": "Impact",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Action_Implementation_Plan",
              "displayName": "Action_Implementation_Plan",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Expected_Outcomes_And_Results",
              "displayName": "Expected_Outcomes_And_Results",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Datasets",
              "displayName": "Datasets",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "AI_Capabilities_And_Tech",
              "displayName": "AI_Capabilities_And_Tech",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Digital_Platforms_And_Tools_And_Models",
              "displayName": "Digital_Platforms_And_Tools_And_Models",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "AI_Algo_And_Frameworks",
              "displayName": "AI_Algo_And_Frameworks",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "References",
              "displayName": "References",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Other_References",
              "displayName": "Other_References",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Timestamp",
              "displayName": "Timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        912,
        1280
      ],
      "id": "65967c9e-28fb-456e-9828-81ab0907b0f9",
      "name": "Store the Output4",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k",
          "mode": "list",
          "cachedResultName": "AI_Use_cases_Perplexity",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 495948948,
          "mode": "list",
          "cachedResultName": "Perplexity LLM Generated Output Data_v2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit#gid=495948948"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        -896,
        1280
      ],
      "id": "0338269d-4a95-4ef2-9930-bfe436cff7aa",
      "name": "Get ID4",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "content": "## Getting Output From Scraped Data LLM Generated output_v3",
        "height": 560,
        "width": 3168,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1152,
        912
      ],
      "id": "54a5bf2e-47b0-4221-9428-a0cca2e034d1",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "1b63c677-ce12-48ea-9d25-701fb30a5b98",
              "leftValue": "={{ $json[\"Generated Output\"] }}",
              "rightValue": " No",
              "operator": {
                "type": "string",
                "operation": "empty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -720,
        1024
      ],
      "id": "594cc384-634c-4477-9b78-acbf465973c6",
      "name": "If3"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "6e9612d3-1d33-4252-8978-53c54663689c",
              "name": "url",
              "value": "={{ $json.url }}",
              "type": "string"
            },
            {
              "id": "912b10d3-fcb4-442c-ba52-b89ec175a0eb",
              "name": "highestIdNum",
              "value": "={{ $json.highestIdNum }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        48,
        1296
      ],
      "id": "9e444e92-2964-45e6-9546-1ef98029c21c",
      "name": "Set Id and URL3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        -528,
        1008
      ],
      "id": "cb9bbf94-ff75-4cff-9fc4-a583801830a3",
      "name": "Limit7"
    },
    {
      "parameters": {
        "keep": "lastItems"
      },
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        1104,
        1280
      ],
      "id": "ea92cfec-1c18-4e17-a2d1-843f16cd4dbb",
      "name": "Limit8"
    },
    {
      "parameters": {
        "jsCode": "// Final Deduplication - improved fingerprint includes Subindustry\nconst toStr = v => (v == null ? \"\" : String(v));\n\nfunction normalizeForComparison(str) {\n  return toStr(str)\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\nfunction createFingerprint(uc) {\n  const core = `${uc.Industry} ${uc.Subindustry || \"\"} ${uc.Business_Function} ${uc.Title_Of_AI_Use_Case}`;\n  return normalizeForComparison(core);\n}\n\nfunction levenshteinDistance(a, b) {\n  const s1 = a.toLowerCase(), s2 = b.toLowerCase();\n  const costs = new Array(s2.length + 1);\n  for (let j = 0; j <= s2.length; j++) costs[j] = j;\n  for (let i = 1; i <= s1.length; i++) {\n    let lastValue = i;\n    for (let j = 1; j <= s2.length; j++) {\n      let newValue = costs[j - 1];\n      if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {\n        newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;\n      }\n      costs[j - 1] = lastValue;\n      lastValue = newValue;\n    }\n    costs[s2.length] = lastValue;\n  }\n  return costs[s2.length];\n}\n\nfunction similarity(a, b) {\n  const longer = a.length >= b.length ? a : b;\n  const shorter = a.length >= b.length ? b : a;\n  if (longer.length === 0) return 1.0;\n  const dist = levenshteinDistance(longer, shorter);\n  return (longer.length - dist) / longer.length;\n}\n\nfunction areDuplicates(uc1, uc2) {\n  const fp1 = createFingerprint(uc1);\n  const fp2 = createFingerprint(uc2);\n  if (fp1 === fp2) return true;\n  const titleSim = similarity(\n    normalizeForComparison(uc1.Title_Of_AI_Use_Case),\n    normalizeForComparison(uc2.Title_Of_AI_Use_Case)\n  );\n  return titleSim > 0.85;\n}\n\nfunction selectBetter(a, b) {\n  const d1 = toStr(a.Description).length;\n  const d2 = toStr(b.Description).length;\n  return d2 > d1 ? b : a;\n}\n\nconst inputItems = $input.all().map(i => i.json).filter(Boolean);\nconst unique = [];\nconsole.log(`Starting deduplication on ${inputItems.length} items`);\n\nfor (const uc of inputItems) {\n  let dup = false;\n  for (let i = 0; i < unique.length; i++) {\n    if (areDuplicates(uc, unique[i])) {\n      console.log(`Merging duplicate: \"${toStr(uc.Title_Of_AI_Use_Case)}\"`);\n      unique[i] = selectBetter(unique[i], uc);\n      dup = true; break;\n    }\n  }\n  if (!dup) unique.push(uc);\n}\n\nconsole.log(`Deduplication complete: ${inputItems.length} -> ${unique.length} unique`);\nreturn unique.map(uc => ({ json: uc }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        1008
      ],
      "id": "f391acd9-9614-4362-ae98-181db6f0d0b7",
      "name": "Final Deduplication"
    },
    {
      "parameters": {
        "jsCode": "// This ensures the loop continues even if individual API calls fail\n\nconst input = $input.all();\n\n// Check if we have valid data\nif (!input || input.length === 0) {\n  console.log(\"No input data - returning empty result to continue loop\");\n  return [{\n    json: {\n      message: \"[]\", // Empty JSON array for downstream processing\n      chunk_index: $json?.chunk_index || 0,\n      documentId: $json?.documentId || \"\",\n      content: $json?.content || \"\"\n    }\n  }];\n}\n\n// Check if the API response is valid\nconst firstItem = input[0];\nif (!firstItem.json?.message) {\n  console.log(\"Invalid API response - returning empty result\");\n  return [{\n    json: {\n      message: \"[]\",\n      chunk_index: firstItem.json?.chunk_index || 0,\n      documentId: firstItem.json?.documentId || \"\",\n      content: firstItem.json?.content || \"\"\n    }\n  }];\n}\n\n// Return the original data if valid\nreturn input;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        640,
        1008
      ],
      "id": "30fc61a4-331a-49cb-9638-0c9ff4693b60",
      "name": "Error Handler Node1"
    },
    {
      "parameters": {
        "jsCode": "// Accumulator Node - Simple pass-through collector\nconst allItems = $input.all();\nconsole.log(`Accumulator: Received ${allItems.length} items`);\n\nreturn allItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        1008
      ],
      "id": "baee1d30-179f-471e-9c96-65560690e042",
      "name": "Accumulator Node1"
    },
    {
      "parameters": {
        "jsCode": "// Final Validation and completion aligned to updated fields\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\nconst hasValue = v => toStr(v).length > 0;\n\nfunction splitItems(s) {\n  return toStr(s)\n    .replace(/\\s*;\\s*/g, \",\")\n    .replace(/\\s+and\\s+/gi, \",\")\n    .split(\",\")\n    .map(x => x.trim())\n    .filter(Boolean);\n}\n\nconst CONSERVATIVE_DEFAULTS = {\n  Digital_Platforms_And_Tools_And_Models: \"AWS SageMaker, Azure ML\",\n  AI_Capabilities_And_Tech: \"Predictive Analytics, Natural Language Processing\",\n  AI_Algo_And_Frameworks: \"Random Forest, Gradient Boosting\"\n};\n\nfunction ensureMinimums(uc) {\n  const out = { ...uc };\n\n  // Digital_Platforms_And_Tools_And_Models: ≤10 items, conservative defaults if empty\n  let dptm = splitItems(out.Digital_Platforms_And_Tools_And_Models);\n  if (dptm.length === 0) dptm = splitItems(CONSERVATIVE_DEFAULTS.Digital_Platforms_And_Tools_And_Models);\n  out.Digital_Platforms_And_Tools_And_Models = dptm.slice(0, 10).join(\", \");\n\n  // AI_Capabilities_And_Tech: ≥2\n  let caps = splitItems(out.AI_Capabilities_And_Tech);\n  if (caps.length < 2) {\n    const def = splitItems(CONSERVATIVE_DEFAULTS.AI_Capabilities_And_Tech);\n    caps = [...caps, ...def].slice(0, Math.max(2, caps.length + def.length));\n  }\n  out.AI_Capabilities_And_Tech = caps.join(\", \");\n\n  // AI_Algo_And_Frameworks: ≥2\n  let algos = splitItems(out.AI_Algo_And_Frameworks);\n  if (algos.length < 2) {\n    const def = splitItems(CONSERVATIVE_DEFAULTS.AI_Algo_And_Frameworks);\n    algos = [...algos, ...def].slice(0, Math.max(2, algos.length + def.length));\n  }\n  out.AI_Algo_And_Frameworks = algos.join(\", \");\n\n  return out;\n}\n\nfunction enforceLengths(uc) {\n  const out = { ...uc };\n  const desc = toStr(out.Description);\n  const words = desc.split(/\\s+/).filter(Boolean);\n  if (words.length < 70) {\n    console.log(`Short description (${words.length} words): ${toStr(out.Title_Of_AI_Use_Case)}`);\n  } else if (words.length > 150) {\n    out.Description = words.slice(0, 150).join(\" \") + \"...\";\n  }\n\n  if (out.Impact && out.Impact.length > 200) {\n    out.Impact = out.Impact.slice(0, 200).trim() + \"...\";\n  }\n  if (out.Expected_Outcomes_And_Results && out.Expected_Outcomes_And_Results.length > 200) {\n    out.Expected_Outcomes_And_Results = out.Expected_Outcomes_And_Results.slice(0, 200).trim() + \"...\";\n  }\n  return out;\n}\n\nfunction isValid(uc) {\n  return hasValue(uc.Title_Of_AI_Use_Case) &&\n         hasValue(uc.Description) &&\n         hasValue(uc.Industry) &&\n         toStr(uc.Description).length >= 50;\n}\n\nconst results = [];\nlet validCount = 0, invalidCount = 0;\n\nfor (const item of $input.all()) {\n  const uc = item.json;\n  if (!isValid(uc)) {\n    console.log(`Invalid use case: ${toStr(uc?.Title_Of_AI_Use_Case) || 'No title'}`);\n    invalidCount++;\n    continue;\n  }\n  let out = ensureMinimums(uc);\n  out = enforceLengths(out);\n  results.push({ json: out });\n  validCount++;\n}\nconsole.log(`Validation: ${validCount} valid, ${invalidCount} invalid`);\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1424,
        1008
      ],
      "id": "fca72efb-ee0e-4233-8338-6004a4f37f3b",
      "name": "Validation1"
    },
    {
      "parameters": {
        "jsCode": "// Use Case Integrity Check - updated to new schema\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\n\nfunction validateUseCase(uc) {\n  const errors = [];\n  if (!toStr(uc.Title_Of_AI_Use_Case)) errors.push(\"Missing title\");\n  const desc = toStr(uc.Description);\n  if (!desc || desc.length < 50) errors.push(\"Description too short or missing\");\n  if (!toStr(uc.Industry)) errors.push(\"Missing industry\");\n  // Companies_Involved must exist as string (empty allowed)\n  if (uc.Companies_Involved == null) errors.push(\"Missing Companies_Involved field\");\n  return errors;\n}\n\n// Ensure comma-separated normalization for tech fields\nconst TECH_FIELDS = [\n  \"AI_Capabilities_And_Tech\",\n  \"Digital_Platforms_And_Tools_And_Models\",\n  \"AI_Algo_And_Frameworks\"\n];\n\nfunction normalizeListField(s) {\n  if (!s) return \"\";\n  let v = String(s)\n    .replace(/\\s*;\\s*/g, \", \")\n    .replace(/\\s+and\\s+/gi, \", \")\n    .replace(/\\s*,\\s*/g, \", \")\n    .trim();\n  // collapse multiple commas\n  v = v.replace(/,+\\s*,+/g, \", \").replace(/\\s*,\\s*/g, \", \");\n  return v;\n}\n\nfunction cleanUseCase(uc) {\n  const cleaned = { ...uc };\n\n  // Stringify long-form fields safely\n  if (cleaned.Description != null) cleaned.Description = toStr(cleaned.Description);\n  if (cleaned.Impact != null) cleaned.Impact = toStr(cleaned.Impact);\n  if (cleaned.Expected_Outcomes_And_Results != null) cleaned.Expected_Outcomes_And_Results = toStr(cleaned.Expected_Outcomes_And_Results);\n\n  // Companies_Involved must be a string; if array -> comma string; if absent -> \"\"\n  if (Array.isArray(cleaned.Companies_Involved)) {\n    cleaned.Companies_Involved = cleaned.Companies_Involved.map(x => toStr(x)).filter(Boolean).join(\", \");\n  }\n  if (cleaned.Companies_Involved == null) cleaned.Companies_Involved = \"\";\n\n  // Normalize tech list fields\n  for (const f of TECH_FIELDS) {\n    if (cleaned[f]) cleaned[f] = normalizeListField(cleaned[f]);\n  }\n\n  // Other_References: normalize arrays/objects to semicolon string\n  if (Array.isArray(cleaned.Other_References)) {\n    cleaned.Other_References = cleaned.Other_References.map(x => toStr(x)).filter(Boolean).join(\"; \");\n  } else {\n    cleaned.Other_References = toStr(cleaned.Other_References);\n  }\n\n  return cleaned;\n}\n\nconst results = [];\nlet valid = 0, invalid = 0;\n\nfor (const item of $input.all()) {\n  const uc = item.json;\n  // Ensure presence of Companies_Involved field for validation consistency\n  if (uc && uc.Companies_Involved == null) uc.Companies_Involved = \"\";\n  const errors = validateUseCase(uc || {});\n  if (errors.length === 0) {\n    const cleaned = cleanUseCase(uc);\n    results.push({ json: cleaned });\n    valid++;\n  } else {\n    console.log(`Invalid use case: ${toStr(uc?.Title_Of_AI_Use_Case) || 'No title'} - ${errors.join(', ')}`);\n    invalid++;\n  }\n}\nconsole.log(`Integrity check: ${valid} valid, ${invalid} invalid`);\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1232,
        1008
      ],
      "id": "4d5932ca-7d77-4847-b5e8-643749eb9960",
      "name": "Use Case Integrity Check1"
    },
    {
      "parameters": {
        "jsCode": "// Subindustry Enricher - aligned with updated fallback library\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\nconst hasValue = v => toStr(v).length > 2;\n\nconst FALLBACKS = {\n  finance: [\"Banking\", \"Insurance\", \"Wealth Management\"],\n  healthcare: [\"Health Care Providers\", \"Pharmaceuticals\", \"Biotechnology\"],\n  retail: [\"E‑Commerce\", \"Grocery\", \"Fashion\"],\n  manufacturing: [\"Automotive\", \"Electronics\", \"Industrial Machinery\"],\n  energy: [\"Energy\", \"Utilities\", \"Renewables\"],\n  telecom: [\"Telecommunications\", \"Network Operators\", \"Communications\"],\n  technology: [\"Software\", \"Data & AI Platforms\", \"Cloud Services\"]\n};\n\nfunction deriveSubindustry(industry, title, description) {\n  const text = `${toStr(industry)} ${toStr(title)} ${toStr(description)}`.toLowerCase();\n\n  // Context cues\n  if (/(predictive maintenance|condition monitoring|asset health)/i.test(text)) return \"Industrial Machinery\";\n  if (/(quality control|defect detection|computer vision qc)/i.test(text)) return \"Electronics\";\n  if (/(e-?commerce|recommendation|personalization|merchandising)/i.test(text)) return \"E‑Commerce\";\n  if (/(grocery|assortment|planogram)/i.test(text)) return \"Grocery\";\n  if (/(bank|credit|loan|card|transaction)/i.test(text)) return \"Banking\";\n  if (/(insurance|claims|underwriting|policy)/i.test(text)) return \"Insurance\";\n  if (/(hospital|clinical|ehr|patient|triage|diagnos)/i.test(text)) return \"Health Care Providers\";\n  if (/(pharma|drug|trial|compound|molecule)/i.test(text)) return \"Pharmaceuticals\";\n  if (/(grid|renewable|solar|wind|meter)/i.test(text)) return \"Energy\";\n\n  // Industry-based fallback\n  const ind = toStr(industry).toLowerCase();\n  for (const key of Object.keys(FALLBACKS)) {\n    if (ind.includes(key)) return FALLBACKS[key];\n  }\n  return \"\";\n}\n\nconst results = [];\nlet enrichedCount = 0;\n\nfor (const item of $input.all()) {\n  const uc = { ...(item.json || {}) };\n  if (!uc || !hasValue(uc.Title_Of_AI_Use_Case)) { results.push(item); continue; }\n  if (!hasValue(uc.Subindustry) && hasValue(uc.Industry)) {\n    const sub = deriveSubindustry(uc.Industry, uc.Title_Of_AI_Use_Case, uc.Description);\n    if (hasValue(sub)) {\n      uc.Subindustry = sub;\n      enrichedCount++;\n      console.log(`Added Subindustry: ${uc.Subindustry}`);\n    }\n  }\n  results.push({ json: uc });\n}\nconsole.log(`Subindustry enriched: ${enrichedCount} use cases`);\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        1008
      ],
      "id": "e507291d-1090-415a-ac0d-810f7f327015",
      "name": "Subindustry Enricher1"
    },
    {
      "parameters": {
        "jsCode": "// Utility: extract trailing integer from an Id string, tolerant of prefixes (e.g., \"UC12\", \"uc-007\", \"15\")\nfunction extractTrailingNumber(idStr) {\n  if (!idStr && idStr !== 0) return null;\n  const s = String(idStr).trim();\n  // Match last run of digits in the string\n  const m = s.match(/(\\d+)\\s*$/);\n  if (!m) return null;\n  const n = parseInt(m[1], 10);\n  return Number.isNaN(n) ? null : n;\n}\n\n// 1) Gather all incoming items\nconst items = $input.all();\n\n// 2) Find the highest numeric suffix from any \"Id\" fields\nlet maxNum = 0;\nfor (const it of items) {\n  const idVal =\n    it.json?.Id ??\n    it.json?.id ?? // be tolerant of lowercase\n    null;\n\n  const num = extractTrailingNumber(idVal);\n  if (num !== null && num > maxNum) {\n    maxNum = num;\n  }\n}\n\n// 3) Extract a URL to carry forward (Merge1 should provide an item with URL)\nlet foundUrl = \"\";\nfor (const it of items) {\n  const urlCandidate =\n    it.json?.URL ??\n    it.json?.Url ??\n    it.json?.url ??\n    \"\";\n  if (urlCandidate && String(urlCandidate).trim()) {\n    foundUrl = String(urlCandidate).trim();\n    break; // take the first non-empty URL\n  }\n}\n\n// 4) Prepare a single control item that downstream nodes can read\nconst controlItem = {\n  json: {\n    highestIdNum: maxNum,\n    nextIdNum: maxNum + 1,\n    url: foundUrl\n  }\n};\n\n// 5) Option A: return original items plus the control item (default)\n//return [...items, controlItem];\n\n// 5) Option B: if you prefer returning only the control item, replace the line above with:\n return [controlItem];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -144,
        1296
      ],
      "id": "7fe60955-8716-42b4-b4fe-969daae1daff",
      "name": "Get Id and URL1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "14bf176b-4bdc-460e-9936-64e71a8458cd",
              "name": "documentId",
              "value": "={{ $json.documentId }}",
              "type": "string"
            },
            {
              "id": "1bd1a34f-16ab-4cb8-a0b2-9baee8ec73b5",
              "name": "determinedAs",
              "value": "={{ $('Get Document URL4').item.json.determinedAs }}",
              "type": "string"
            },
            {
              "id": "4869bd92-11cf-49d7-88d2-58c2e7427adf",
              "name": "contentHint",
              "value": "={{ $('Get Document URL4').item.json.contentHint }}",
              "type": "string"
            },
            {
              "id": "1ddde114-bfd9-4ba6-bef2-c23c2f3c2721",
              "name": "isSingleUseCase",
              "value": "={{ $('Get Document URL4').item.json.isSingleUseCase }}",
              "type": "string"
            },
            {
              "id": "8e22c109-c631-4cb7-8390-702ff9b91af0",
              "name": "shouldProcess",
              "value": "={{ $('Get Document URL4').item.json.shouldProcess }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -48,
        1008
      ],
      "id": "0be418b7-fea1-40f2-8122-9c7e533dd025",
      "name": "Set Doc Id1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -368,
        1296
      ],
      "id": "c3066b5c-5292-4055-b798-063f55c73298",
      "name": "Merge Reference URL1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        480,
        1280
      ],
      "id": "99aa27fd-28fa-4127-bb4a-86cf32b8d7ac",
      "name": "Merge All Data1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1328,
        1264
      ],
      "id": "13c06328-1067-48c8-b6c4-5b895d7945c0",
      "name": "Update URLs to scrape sheet2"
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1663435215,
          "mode": "list",
          "cachedResultName": "Copy of Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=1663435215"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Generated Output": "Yes",
            "Document ID": "={{ $json.documentId }}"
          },
          "matchingColumns": [
            "Document ID"
          ],
          "schema": [
            {
              "id": "URL",
              "displayName": "URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Title",
              "displayName": "Title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Document ID",
              "displayName": "Document ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Document URL",
              "displayName": "Document URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is Scraped",
              "displayName": "Is Scraped",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is deleted",
              "displayName": "Is deleted",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Generated Output",
              "displayName": "Generated Output",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        1728,
        1264
      ],
      "id": "5bf36637-2fab-4489-8815-3988da9bc805",
      "name": "Update URLs to scrape sheet3",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Robust Flatten Output for updated schema\n// - Parses message (array/object/string, fenced/quoted) into array\n// - Normalizes to new mandatory keys\n// - Enforces Companies_Involved (\"\" if absent) and Other_References (array->semicolon string)\nconst REQUIRED_KEYS = [\n  \"Industry\",\"Subindustry\",\"Business_Function\",\"Business_Capability\",\n  \"Stakeholder_Or_User\",\"Companies_Involved\",\"Title_Of_AI_Use_Case\",\"Description\",\"Impact\",\n  \"Action_Implementation_Plan\",\"Expected_Outcomes_And_Results\",\"Datasets\",\n  \"AI_Capabilities_And_Tech\",\"Digital_Platforms_And_Tools_And_Models\",\n  \"AI_Algo_And_Frameworks\",\"Other_References\"\n];\n\nconst toStr = v => (v == null ? \"\" : String(v));\nconst isObj = v => v && typeof v === \"object\" && !Array.isArray(v);\n\nfunction cleanMessageString(s) {\n  if (!s) return \"\";\n  let str = String(s).trim();\n  // strip leading tokens and fenced code\n  str = str.replace(/^\\s*json\\s*/i, \"\").trim();\n  str = str.replace(/``````/g, \"\").trim();\n  // remove leading/trailing markdown noise\n  str = str.replace(/^\\s*Output:\\s*/i, \"\").trim();\n  return str;\n}\n\nfunction tryParseJson(s) {\n  try { return JSON.parse(s); } catch { return null; }\n}\n\n// Extract top-level {...} objects even if not inside an array\nfunction extractObjectsFromString(s) {\n  const objs = [];\n  let depth = 0, start = -1;\n  for (let i = 0; i < s.length; i++) {\n    const ch = s[i];\n    if (ch === \"{\") { if (depth === 0) start = i; depth++; }\n    else if (ch === \"}\") {\n      depth--;\n      if (depth === 0 && start !== -1) {\n        objs.push(s.slice(start, i + 1));\n        start = -1;\n      }\n    }\n  }\n  return objs;\n}\n\nfunction parseToArray(raw) {\n  if (raw == null) return null;\n  if (Array.isArray(raw)) return raw.slice();\n  if (isObj(raw)) return [raw];\n\n  let s = cleanMessageString(String(raw));\n\n  // Unquote double-encoded JSON\n  if ((s.startsWith('\"') && s.endsWith('\"')) || (s.startsWith(\"'\") && s.endsWith(\"'\"))) {\n    const unq = tryParseJson(s);\n    if (unq != null) {\n      if (Array.isArray(unq)) return unq;\n      if (isObj(unq)) return [unq];\n      if (typeof unq === \"string\") s = unq.trim();\n    }\n  }\n\n  // Direct parse\n  let p = tryParseJson(s);\n  if (p != null) return Array.isArray(p) ? p : [p];\n\n  // Parse first [...] slice\n  const lb = s.indexOf(\"[\"); const rb = s.lastIndexOf(\"]\");\n  if (lb !== -1 && rb !== -1 && rb > lb) {\n    const slice = s.slice(lb, rb + 1);\n    p = tryParseJson(slice);\n    if (p != null) return Array.isArray(p) ? p : [p];\n  }\n\n  // Parse top-level {...} blocks\n  const objs = extractObjectsFromString(s).map(tryParseJson).filter(o => isObj(o));\n  if (objs.length > 0) return objs;\n\n  return null;\n}\n\n// Merge legacy keys into new schema keys\nfunction harmonizeKeys(obj) {\n  const o = { ...obj };\n  // Legacy fields -> new fields\n  if (o.Digital_Platforms_And_Tools && !o.Digital_Platforms_And_Tools_And_Models) {\n    o.Digital_Platforms_And_Tools_And_Models = o.Digital_Platforms_And_Tools;\n  }\n  if (o.Tools_And_Models && !o.Digital_Platforms_And_Tools_And_Models) {\n    o.Digital_Platforms_And_Tools_And_Models = o.Tools_And_Models;\n  }\n  if (o[\"Other References\"] && !o.Other_References) {\n    o.Other_References = o[\"Other References\"];\n  }\n  if (o.OtherReferences && !o.Other_References) {\n    o.Other_References = o.OtherReferences;\n  }\n  return o;\n}\n\n// Convert arrays to semicolon strings; objects to JSON strings; scalars to trimmed strings\nfunction normalizeFieldValues(obj) {\n  const normalized = {};\n  for (const key of Object.keys(obj)) {\n    let v = obj[key];\n    if (Array.isArray(v)) {\n      normalized[key] = v.map(x => toStr(x).trim()).filter(Boolean).join(\"; \");\n    } else if (isObj(v)) {\n      try { normalized[key] = JSON.stringify(v); } catch { normalized[key] = toStr(v); }\n    } else {\n      normalized[key] = toStr(v).trim();\n    }\n  }\n  // Companies_Involved must exist: empty string if absent\n  if (!Object.prototype.hasOwnProperty.call(normalized, \"Companies_Involved\") || normalized.Companies_Involved == null) {\n    normalized.Companies_Involved = \"\";\n  }\n  // Ensure all REQUIRED_KEYS exist\n  for (const k of REQUIRED_KEYS) {\n    if (!Object.prototype.hasOwnProperty.call(normalized, k)) normalized[k] = \"\";\n  }\n  return normalized;\n}\n\nconst results = [];\nfor (const item of $input.all()) {\n  const chunkIndex = item.json?.chunk_index ?? item.json?._chunk_index ?? null;\n  const documentId = item.json?.documentId ?? item.json?._document_id ?? null;\n  const chunkContent = item.json?.content ?? item.json?._chunk_content ?? \"\";\n  const raw = item.json?.message ?? \"\";\n\n  const arr = parseToArray(raw);\n  if (!arr) {\n    console.log(\"⚠️ Flatten: could not parse message for chunk_index:\", chunkIndex);\n    results.push({\n      json: {\n        _chunk_index: chunkIndex,\n        _documentId: documentId,\n        _chunk_content: toStr(chunkContent),\n        _flag_parse_failed: true,\n        message: raw\n      }\n    });\n    continue;\n  }\n\n  for (const obj of arr) {\n    const harmonized = harmonizeKeys(obj);\n    const normalized = normalizeFieldValues(harmonized);\n\n    const missing = REQUIRED_KEYS.filter(k => !normalized[k] || normalized[k].trim() === \"\");\n    if (missing.length > 0) {\n      normalized._flag_missing_keys = true;\n      normalized._missing_keys = missing;\n      console.log(`⚠️ Flatten: missing keys for chunk ${chunkIndex}:`, missing);\n    }\n\n    results.push({\n      json: {\n        ...normalized,\n        _chunk_index: chunkIndex,\n        _documentId: documentId,\n        _chunk_content: toStr(chunkContent)\n      }\n    });\n  }\n}\nconsole.log(`Flattened ${results.length} items`);\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        848,
        1008
      ],
      "id": "7dd8051e-2f5a-4475-9d55-110731adca8e",
      "name": "Flatten Output1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "model": "sonar",
        "messages": {
          "message": [
            {
              "content": "=You are an extraction engine that converts filteredContent into a single JSON array of AI use cases. Operate only on spans present in filteredContent.\n\nGrounding and scope\n\nSpan-only: Extract only what explicitly appears in filteredContent; never invent or generalize beyond the text. If uncertain, exclude.\n\nExhaustive coverage: Process every heading block in order and extract all valid atoms inside each block before moving on.\n\nTitle anchoring: Copy titles verbatim from the atom span. If none, compose “<NearestHeading> — <first 4–8 words>”.\n\nIgnore navigation/marketing/link lists unless they contain a valid atom span.\n\nAtomic detection (must be visible in text)\n\nBullets/ordered: “- ”, “* ”, “– ”, “— ”, “1. ”, “2. ”, “A. ”, “B. ”\n\nBold-labeled: “Title: …”\n\nStandalone titled sentence at paragraph start: “Title: …”\n\nComplete “Opportunity / Solution / Outcome” triplet under a heading = exactly one atom\n\nDo not merge items; do not split one item. Strict parity: detected atoms = JSON objects.\n\nDeterministic procedure\n\nSegment filteredContent by headings (## or ###) in source order.\n\nWithin each segment, treat separators (“* * *”, “=”, blank lines) as boundaries and detect atoms strictly by the allowed shapes above.\n\nBuild an ordered list of all atoms across all segments. For each atom, set Industry from its nearest heading; stop inheritance at the next heading of same/higher level.\n\nFill the schema from that atom’s span only, with conservative enrichment; if a field cannot be safely inferred from the span, set \"\".\n\nOutput one JSON array whose length equals the total atom count. No extra text.\n\nSchema per object (all keys required)\n\nIndustry (1–2)\n\nSubindustry (≤3)\n\nBusiness_Function (2–3)\n\nBusiness_Capability (2–3)\n\nStakeholder_Or_User (2–3)\n\nAgent_Type (Customer | Employee | Code | Data | Creative | Security | \"\")\n\nCompanies_Involved (explicit names ≤5, else \"\")\n\nTitle_Of_AI_Use_Case\n\nDescription (70–150 words; faithful only to the atom span)\n\nImpact (1–2 lines; non-empty)\n\nAction_Implementation_Plan (exactly 4 numbered steps)\n\nExpected_Outcomes_And_Results (1–2 lines; non-empty)\n\nDatasets (conservatively inferred from the same span)\n\nAI_Capabilities_And_Tech (≥2; no duplicates)\n\nDigital_Platforms_And_Tools_And_Models (5–10 unique; domain-aligned; no duplicates)\n\nAI_Algo_And_Frameworks (4–6 advanced, diverse, context-aligned; e.g., Transformers, Graph Neural Networks, GANs, Variational Autoencoders, Diffusion Models, Reinforcement Learning, Gradient Boosted Trees; no duplicates)\n\nOther_References (≥2 valid URLs; prefer links in or clearly tied to the atom span)\n\nAbsolutes\n\nIf shouldProcess = false → return []\n\nIf isSingleUseCase = true OR determinedAs = \"single\" → return exactly one object from the first valid atom under the first heading\n\nElse process all headings and all atoms exhaustively with strict parity\n\nOutput only one valid JSON array; no commentary",
              "role": "system"
            },
            {
              "content": "=Use only the variables and the filteredContent below to extract all use cases strictly from the text, across all headings.\n\n{{ $json.filteredContent }}\n\nSignals\n\nisSingleUseCase: {{ $json.isSingleUseCase }}\n\ndeterminedAs: {{ $json.determinedAs }}\n\nshouldProcess: {{ $json.shouldProcess }}\n\ncontentHint: {{ $json.contentHint }}\n\nInstructions\n\nIf shouldProcess = \"false\" → return []\n\nIf isSingleUseCase = \"true\" OR determinedAs = \"single\" → return exactly 1 object from the first valid atom under the first heading\n\nOtherwise:\n\nSegment by headings (##/###) in order and fully extract all atoms within each segment before moving on\n\nDetect atoms only if they match one of:\n\nBullets/ordered items\n\n“Title: …”\n\n“Title: …” at paragraph start\n\nA complete “Opportunity / Solution / Outcome” triplet\n\nTreat separators (“* * *”, “=”, blank lines) as boundaries\n\nCopy titles verbatim; if none, compose “<NearestHeading> — <first 4–8 words>”\n\nEnsure JSON array length equals the total number of detected atoms across all headings\n\nFor each object, fill every schema field. If a value cannot be safely inferred from the atom span, set \"\". For AI_Algo_And_Frameworks, always include 4–6 advanced, diverse, context‑aligned items.\n\nOutput\nReturn only a single valid JSON array. No extra text."
            }
          ]
        },
        "simplify": true,
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexity",
      "typeVersion": 1,
      "position": [
        416,
        1008
      ],
      "id": "c24ea29e-ad17-4d18-8f4e-c0b34f47ea38",
      "name": "LLM1",
      "credentials": {
        "perplexityApi": {
          "id": "2X923WJEbWR6QPD5",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Safe input to string\nconst raw = $json.content ?? \"\";\nconst text = typeof raw === \"string\" ? raw : String(raw);\n\n// Normalize line endings to \\n for consistent searching\nconst norm = text.replace(/\\r\\n?/g, \"\\n\");\n\n// Build case-insensitive, full-line marker regexes\n// We anchor to line starts/ends to avoid matching inline occurrences.\nconst startRe = /^[ \\t]*===\\s*USE CASES START BELOW\\s*===[ \\t]*$/im;\nconst endRe   = /^[ \\t]*===\\s*REFERENCES\\s*\\/\\s*SOURCES\\s*===[ \\t]*$/im;\n\n// Find start marker line match\nconst startMatch = norm.match(startRe);\n\nlet extracted = \"\";\nif (startMatch) {\n  // startMatch.index gives start of line; compute end-of-line to begin content after the start marker line\n  const startLineStart = startMatch.index;\n  const startLineEnd = startLineStart + startMatch.length;\n  // Move to after the newline following the start line (if present)\n  const afterStartNewlineIdx = norm.indexOf(\"\\n\", startLineEnd);\n  const contentStart = afterStartNewlineIdx === -1 ? startLineEnd : afterStartNewlineIdx + 1;\n\n  // Search for end marker only after contentStart\n  endRe.lastIndex = contentStart; // ensure search starts after start\n  const endMatch = endRe.exec(norm);\n\n  const contentEnd = endMatch ? endMatch.index : norm.length;\n\n  // Slice original text using equivalent indices in the normalized buffer.\n  // Because we only normalized CRLF->LF, indices still align with norm’s positions.\n  extracted = norm.slice(contentStart, contentEnd).trim();\n}\n\n// Carry forward values\nconst isSingleUseCase = $json.isSingleUseCase ?? null;\nconst determinedAs = $json.determinedAs ?? \"unknown\";\nconst shouldProcess = $json.shouldProcess ?? true;\nconst contentHint = $json.contentHint ?? \"\";\n\n// Keep UI preview bounded, but do NOT affect filteredContent\nconst RAW_PREVIEW_LIMIT = 1000;\nconst rawContentPreview = norm.length > RAW_PREVIEW_LIMIT ? norm.slice(0, RAW_PREVIEW_LIMIT) : norm;\n\nreturn [{\n  json: {\n    filteredContent: extracted, // strictly between the two === ... === markers\n    rawContent: rawContentPreview,\n    rawContentTruncated: norm.length > RAW_PREVIEW_LIMIT,\n    isSingleUseCase,\n    determinedAs,\n    shouldProcess,\n    contentHint\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        1008
      ],
      "id": "38d3d071-5575-4978-bf8f-a0eb670f7ff1",
      "name": "Passing Use Cases only from Content1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "db8cc92c-96d3-4955-a9cf-b958b3647984",
              "name": "URL",
              "value": "={{ $json.data.metadata.url }}",
              "type": "string"
            },
            {
              "id": "03b76a3d-2d10-4dc5-ad5b-c5f737db236c",
              "name": "Title",
              "value": "={{ $json.data.metadata.title }}",
              "type": "string"
            },
            {
              "id": "3bd6afdf-10fc-4ce9-a217-236207ae70d8",
              "name": "Content",
              "value": "={{ $json.data.markdown }}",
              "type": "string"
            },
            {
              "id": "13853381-3037-4689-9a26-78f32cc5b2fa",
              "name": "Document ID",
              "value": "={{ $('Get URLs to scrape1').item.json['Document ID'] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        672,
        384
      ],
      "id": "59235776-737e-4de3-82c5-1801f10e3075",
      "name": "Get content1"
    },
    {
      "parameters": {
        "folderId": "1cU0R27x063BPzfi7dA9pQK2HQ9MSCUQ5",
        "title": "={{ $json.Title }}"
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        2048,
        464
      ],
      "id": "4b444c98-2bab-41ff-a586-0ed099505be6",
      "name": "Create Google Docs1",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        0,
        0
      ],
      "id": "20fcfde9-70a7-4596-a5bf-e287b510ca6d",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "operation": "update",
        "documentURL": "={{ $json.documentId }}",
        "actionsUi": {
          "actionFields": [
            {
              "action": "replaceAll",
              "text": "={{ $json.content }}",
              "replaceText": "={{ $('If7').item.json.cleanedOutput }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        2320,
        288
      ],
      "id": "fde89b8b-5a45-4653-b1e3-1b1bf5a82e6c",
      "name": "Update Text to Google Docs1",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentURL": "={{ $json.id }}",
        "actionsUi": {
          "actionFields": [
            {
              "action": "insert",
              "text": "={{ $('If7').item.json.cleanedOutput }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        2336,
        464
      ],
      "id": "c5ba512c-07e3-40db-aa67-2d6a0f90be41",
      "name": "Save Text to Google Docs",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "documentURL": "={{ $json.DocumentID }}"
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        2032,
        288
      ],
      "id": "8f7de2f7-a60f-4dec-8efd-8d6aacbece0a",
      "name": "Get Google Docs1",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1663435215,
          "mode": "list",
          "cachedResultName": "Copy of Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=1663435215"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Document ID": "={{ $json.documentId }}",
            "Document URL": "=https://docs.google.com/document/d/{{ $json.documentId }}",
            "Is Scraped": "Yes",
            "URL": "={{ $('Code3').item.json.URL }}",
            "Title": "={{ $('Code3').item.json.Title }}",
            "contentHint": "={{ $('Code3').item.json.contentHint }}",
            "isSingleUseCase": "={{ $('Code3').item.json.isSingleUseCase }}",
            "determinedAs": "={{ $('Code3').item.json.determinedAs }}",
            "shouldProcess": "={{ $('Code3').item.json.shouldProcess }}"
          },
          "matchingColumns": [
            "URL"
          ],
          "schema": [
            {
              "id": "URL",
              "displayName": "URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Title",
              "displayName": "Title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Document ID",
              "displayName": "Document ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Document URL",
              "displayName": "Document URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is Scraped",
              "displayName": "Is Scraped",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is deleted",
              "displayName": "Is deleted",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Generated Output",
              "displayName": "Generated Output",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "isSingleUseCase",
              "displayName": "isSingleUseCase",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "determinedAs",
              "displayName": "determinedAs",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "shouldProcess",
              "displayName": "shouldProcess",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "contentHint",
              "displayName": "contentHint",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        2592,
        384
      ],
      "id": "70f8b5a2-5e0b-4df1-b4e7-f68ad0d342de",
      "name": "Update Google Sheets2",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "amount": 10
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2784,
        384
      ],
      "id": "e441256a-bcb4-47cd-a7bb-d11072cc3072",
      "name": "Wait1",
      "webhookId": "90d20a5b-3453-4d82-af3f-b589370a7015"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1663435215,
          "mode": "list",
          "cachedResultName": "Copy of Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=1663435215"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        -176,
        400
      ],
      "id": "27add737-be8a-412e-9a0c-451dc222c120",
      "name": "Get URLs to scrape1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "scrape",
        "url": "={{ $json.URL }}",
        "scrapeOptions": {
          "options": {
            "formats": {
              "format": [
                {}
              ]
            },
            "excludeTags": {
              "items": [
                {
                  "tag": "audio, figure, figcaption, button, form, input, textarea, select, label, script, style, link"
                },
                {
                  "tag": "img"
                },
                {
                  "tag": "footer"
                },
                {
                  "tag": "noscript"
                },
                {
                  "tag": "iframe"
                },
                {
                  "tag": "header"
                },
                {
                  "tag": "nav"
                },
                {
                  "tag": "aside"
                },
                {
                  "tag": "svg"
                },
                {
                  "tag": "video"
                }
              ]
            },
            "headers": {}
          }
        },
        "requestOptions": {}
      },
      "type": "@mendable/n8n-nodes-firecrawl.firecrawl",
      "typeVersion": 1,
      "position": [
        464,
        384
      ],
      "id": "abd06e2e-9c0b-4c64-b2aa-f4d404f97d2b",
      "name": "Scrape a url and get its content",
      "credentials": {
        "firecrawlApi": {
          "id": "ogqoeHzW3hEaFFhK",
          "name": "Firecrawl account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "5ac134b7-1d5a-45ad-81c9-b469a0d0e8a6",
              "leftValue": "={{ $json.DocumentID }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1808,
        384
      ],
      "id": "8a306011-c561-4fe3-a3ca-89d4bfdeebe4",
      "name": "If7"
    },
    {
      "parameters": {
        "content": "## Scraping URL with FireCrawl & save to Google Sheets & option to re-scrape_v3",
        "height": 416,
        "width": 3408
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -416,
        272
      ],
      "id": "bc947304-53d7-4b7d-970f-80c6725de40d",
      "name": "Sticky Note12"
    },
    {
      "parameters": {
        "model": "sonar",
        "messages": {
          "message": [
            {
              "content": "=Role: strict line-by-line classifier and formatter. Do not shorten, paraphrase, or invent wording — only move raw input lines into exactly three sections, preserving original line breaks and Markdown formatting.\n\nOutput order (always exactly this):\n=== PARAGRAPHS / CONTEXT ===\n=== USE CASES START BELOW ===\n=== REFERENCES / SOURCES ===\n\nDefinitions:\n\nPARAGRAPHS: Background, intros, general info, analysis, surveys/methodology, definitions, marketing blurbs, section headings not describing an application, author bios, newsletter prompts, “More from this author,” sponsored blurbs, event promos, careers, awards, and generic statements about AI benefits. Keep them verbatim and in order.\n\nUSE CASES: Only lines that describe applications, implementations, deployments, examples, solutions, scenarios, partnerships, customer stories, adoption, named companies tied to applications, tools/technologies used, or “how it is applied.” Copy sentences exactly.\n\nREFERENCES: Any line that contains a URL/link or link-like token, including http, https, www., or a domain/file ending such as .com, .org, .net, .io, .ai, .co, .in, .html, .htm, .php, .aspx, .pdf; also “Read more,” “Learn more,” “Subscribe,” citations, or link-rich lists. Entire such lines go only here. Non-negotiable.\n\nUse-case block detection:\n\nBlock starters: treat these as the start of a USE CASES block and route them and subsequent related items to USE CASES unless a clear non-use-case heading interrupts:\n\nLines starting with “Use case”, “Use cases”, “Case study/ies”, “Examples”, “Customer stories”, “Applications”, “Implementations”, “Scenarios” (case-insensitive).\n\nNumbered or bulleted markers followed by an applied topic, e.g., “1.”, “1)”, “(1)”, “I.”, “A)”, “- ”, “- ”, “— ”, when the text describes how AI is used or names a company/tool/solution.\n\nMarkdown headings that enumerate applied topics, e.g., “## 1. …”, “### Use cases”, or “## Predictive maintenance” followed by deployments or named companies/tools.\n\nBlock continuation: once a use-case block starts, keep subsequent lines in USE CASES until:\n\nA new top-level or peer heading unrelated to applications appears (e.g., “Feature”, “Subscribe”, “Author”, “More from this author”), then switch back to PARAGRAPHS; or\n\nAn explicit “References/Read more/Subscribe/Sponsored/Links” region appears (send those lines to REFERENCES); or\n\nA new use-case block starter appears (continue in USE CASES).\n\nInterleaved context: if a clearly non-applied paragraph appears inside a use-case list (e.g., survey methodology or generic benefits), place only that line in PARAGRAPHS, but do not break the ongoing USE CASES block for the following items.\n\nGlobal rules:\n\nNever summarize, compress, or reword; keep names, numbers, and technical terms intact.\n\nPreserve original Markdown and line order within each section.\n\nSingle use case page: if explicitly stated by the user prompt, put all non-link lines in USE CASES; still route link-containing lines to REFERENCES.\n\nIf a section would be empty, include its heading and write “None”.\n\nExclusions from USE CASES: introductions, analysis, survey descriptions, list headings that don’t describe applications, generic benefits, author bios, newsletter signup text, sponsored/link blocks, event promos, careers.\n\nPriority for ambiguous lines:\n\nLinks → REFERENCES; lines inside a detected use-case block → USE CASES; otherwise → PARAGRAPHS.\n\nMandatory self-check before final output:\n\nSweep USE CASES and PARAGRAPHS; if any line contains http/https/www or ends with a domain/file pattern above, move that entire line to REFERENCES.\n\nEnsure each link-like line appears only once under REFERENCES; remove duplicates elsewhere.\n\nVerify that numbered/bulleted items under a use-case heading are in USE CASES; if any are not, move them into USE CASES as a contiguous group until the next non-use-case heading.\n\nOutput only the three sections in the required order; no extra commentary.\n\nFew-shot anchors (do not generalize wording; follow behavior):\nExample A\nInput lines:\n\n“## Use cases”\n\n“1. Predictive maintenance — GE analyzes engine data…”\n\n“2. Customer service — Lufthansa scaled digital support…”\n\n“Subscribe to our newsletter”\nBehavior:\n\nLines 1–3 → USE CASES; “Subscribe to our newsletter” → REFERENCES if it contains a link, otherwise PARAGRAPHS.\n\nExample B\nInput lines:\n\n“From chatbots to predictive maintenance…”\n\n“## 1. Cloud pricing optimization”\n\n“Organizations use AI to reduce cloud costs…”\n\n“## 2. Predictive maintenance”\n\n“GE analyzes engine data…”\nBehavior:\n\nIntro → PARAGRAPHS; “## 1…” and following descriptive line → USE CASES; “## 2…” and following line → USE CASES.",
              "role": "system"
            },
            {
              "content": "=Reorganize the following content into the 3-section format defined by your system rules. Do not change, shorten, or rephrase any text. Classify line-by-line and preserve original formatting.\n\nSource URL: {{ $json.URL }}\nTitle: {{ $json.Title }}\nContent Type Hint: {{ $json.contentHint }}\nBatch Info: {{ $json.BatchIndex }}/{{ $json.TotalBatches }}\n\nContent:\n{{ $json.Content }}\n\nProcessing directive:\n{{ $json.isSingleUseCase\n? \"This is part of a SINGLE use case page. Put all non-link lines in USE CASES. Any line containing a URL goes to REFERENCES.\"\n: \"Move only application/implementation lines to USE CASES; keep introductions, analysis, survey context, headings, author bios, newsletter/sponsored blocks, and general descriptions in PARAGRAPHS. Any line containing a URL must go to REFERENCES.\" }}\n\nHard constraints to enforce before returning:\n\nIf any line in USE CASES or PARAGRAPHS contains http, https, www., or ends with .com/.org/.net/.io/.ai/.co/.in/.html/.htm/.php/.aspx/.pdf, move that entire line to REFERENCES.\n\nDetect use-case block starters (e.g., lines beginning with “Use case…”, numbered/lettered items like “1.”, “1)”, “(1)”, “A)”, or headings like “## 1. …”) and keep subsequent list items in USE CASES until a non-use-case heading appears.\n\nDo not leave any link-containing lines outside REFERENCES. If duplicates exist, keep only one under REFERENCES.\n\nConflict resolution priority:\n\nLinks → REFERENCES; 2) Lines inside a detected use-case block → USE CASES; 3) Otherwise → PARAGRAPHS.\n\nReturn only:\n=== PARAGRAPHS / CONTEXT ===\n…content…\n=== USE CASES START BELOW ===\n…content…\n=== REFERENCES / SOURCES ===\n…content…"
            }
          ]
        },
        "simplify": true,
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexity",
      "typeVersion": 1,
      "position": [
        1040,
        384
      ],
      "id": "3115a76f-8d02-4cc4-9875-b3aaea544648",
      "name": "Get Structured Output1",
      "credentials": {
        "perplexityApi": {
          "id": "2X923WJEbWR6QPD5",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "1bcf4242-d114-471d-b842-2315e847de82",
              "leftValue": "={{ $json['Is Scraped'] }}",
              "rightValue": "No",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        32,
        400
      ],
      "id": "d533f28c-8b21-4b8a-9424-9c620205471d",
      "name": "If9"
    },
    {
      "parameters": {
        "jsCode": "// Universal Content Analyzer for n8n - With Paragraph-Aware Batching\n\nconst content = $json.Content || \"\";\nconst title = $json.Title || \"\";\nconst url = $json.URL || \"\";\n\n// === Clean content ===\n// Normalize whitespace but preserve paragraph breaks\nconst cleanedContent = content\n  .replace(/\\r\\n/g, \"\\n\")     // normalize line endings\n  .replace(/[ \\t]+/g, \" \")    // collapse spaces/tabs\n  .replace(/\\n{2,}/g, \"\\n\\n\") // keep max one empty line\n  .trim();\n\n// === Utility: Split text into batches by paragraph boundaries ===\nfunction splitByParagraphs(text, maxChars = 12000) {\n  const paragraphs = text.split(/\\n+/); // split by line breaks\n  const batches = [];\n  let currentBatch = \"\";\n\n  for (const p of paragraphs) {\n    // If adding this paragraph would exceed maxChars, start a new batch\n    if ((currentBatch + p).length > maxChars) {\n      if (currentBatch.trim()) {\n        batches.push(currentBatch.trim());\n      }\n      currentBatch = \"\";\n    }\n    currentBatch += p + \"\\n\";\n  }\n\n  if (currentBatch.trim()) {\n    batches.push(currentBatch.trim());\n  }\n\n  return batches;\n}\n\n// === Use case type detection ===\nfunction detectUseCaseCount(text, pageTitle, pageUrl) {\n  const combined = (text + \" \" + pageTitle).toLowerCase();\n\n  const strongSinglePatterns = [\n    /case study/i,\n    /success story/i,\n    /customer story/i,\n    /customer spotlight/i,\n    /press release/i,\n    /announcement/i,\n    /announces/i,\n    /partners with/i,\n    /collaborates with/i,\n    /joins forces with/i,\n    /teams up with/i,\n    /implements .+ solution/i,\n    /deploys .+ platform/i,\n    /migrates to/i,\n    /selects .+ (for|to)/i,\n    /chooses .+ (for|to)/i,\n  ];\n\n  const multiplePatterns = [\n    /\\b\\d+\\s+(use cases?|applications?|examples?|ways|scenarios?)\\b/i,\n    /\\b(top|best|key)\\s+\\d+\\s+/i,\n    /(?:^|\\n)\\d+[\\.\\)]\\s+.+(?:\\n\\d+[\\.\\)]\\s+.+){1,}/m,\n    /(?:^|\\n)[a-zA-Z][\\.\\)]\\s+.+(?:\\n[a-zA-Z][\\.\\)]\\s+.+){1,}/m,\n    /(?:^|\\n)\\s*[-*•]\\s+.+(?:\\n\\s*[-*•]\\s+.+){1,}/m\n  ];\n\n  let forcedSingle = false;\n  let forcedMultiple = false;\n\n  if (pageUrl) {\n    const u = pageUrl.toLowerCase();\n    if (u.includes(\"case-study\") || u.includes(\"success-story\") || u.includes(\"customer-story\") || u.includes(\"press-release\")) {\n      forcedSingle = true;\n    }\n    if (u.includes(\"use-cases\") || u.includes(\"examples\") || u.includes(\"applications\")) {\n      forcedMultiple = true;\n    }\n  }\n\n  const matchedSingle = strongSinglePatterns.some(p => p.test(combined));\n  const matchedMultiple = multiplePatterns.some(p => p.test(text));\n\n  if (matchedSingle || forcedSingle) {\n    return { isSingleUseCase: true, contentHint: \"SINGLE_USE_CASE_PAGE\" };\n  }\n  if (matchedMultiple || forcedMultiple) {\n    return { isSingleUseCase: false, contentHint: \"MULTIPLE_USE_CASES_PAGE\" };\n  }\n\n  return { isSingleUseCase: true, contentHint: \"SINGLE_USE_CASE_PAGE\" };\n}\n\n// === Relevance check ===\nfunction isRelevantContent(text, title) {\n  const combined = (text + \" \" + title).toLowerCase();\n  const relevancePatterns = [\n    \"use case\", \"application\", \"implementation\", \"deployment\",\n    \"case study\", \"success story\", \"example\", \"scenario\",\n    \"solution\", \"transform\", \"ai\", \"ml\", \"artificial intelligence\",\n    \"automation\", \"cloud\", \"digital transformation\"\n  ];\n  return relevancePatterns.some(p => combined.includes(p));\n}\n\n// === Main Analysis ===\nconst analysis = detectUseCaseCount(cleanedContent, title, url);\nconst isRelevant = isRelevantContent(cleanedContent, title);\n\n// === Split into paragraph-aware batches ===\nconst batches = splitByParagraphs(cleanedContent, 12000);\n\nreturn batches.map((batch, i) => ({\n  URL: url,\n  Title: title,\n  BatchIndex: i + 1,\n  TotalBatches: batches.length,\n  Content: batch,\n  contentHint: analysis.contentHint,\n  isSingleUseCase: analysis.isSingleUseCase,\n  isRelevant: isRelevant,\n  debug: { \n    determinedAs: analysis.isSingleUseCase ? \"SINGLE\" : \"MULTIPLE\",\n    batchLength: batch.length \n  },\n  shouldProcess: isRelevant\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        384
      ],
      "id": "746b634e-991c-4540-8e4d-4ac82d9e30ec",
      "name": "Universal Content Analyzer1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "e97e6670-4c89-4c5e-8ad8-ab8d19e643de",
              "leftValue": "={{ $json.documentId }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1536,
        1264
      ],
      "id": "b19d61aa-ce32-439c-aa9c-a0372513cea1",
      "name": "If4"
    },
    {
      "parameters": {
        "jsCode": "// === Code3 Node (Final Cleaner with Flattened determinedAs) ===\n\nreturn {\n  json: {\n    Title: $json.Title || null,\n    DocumentID: $json.DocumentID || null,\n    URL: $json.URL || null,\n    contentHint: $json.contentHint || null,\n    isSingleUseCase: $json.isSingleUseCase ?? null,\n    isRelevant: $json.isRelevant ?? null,\n    shouldProcess: $json.shouldProcess ?? null,\n    determinedAs: $json.determinedAs || null,   // ✅ flatten at root\n    cleanedOutput: $json.FinalOutput || null,\n    }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        384
      ],
      "id": "f10580a9-cf63-4c81-8cb2-3fe86a33582b",
      "name": "Code3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        256,
        384
      ],
      "id": "529b2c77-d9fb-44a9-abbb-4668852ded82",
      "name": "Limit9"
    },
    {
      "parameters": {
        "jsCode": "// === Combine Node (3-Section Merger with Metadata, flattened determinedAs) ===\n\nconst groups = {};\n\nfor (const item of items) {\n  const key = item.json.GroupKey || \"default\";\n\n  // Safely pull metadata\n  const title = item.json.Title || item.json.title || null;\n  const docId = item.json[\"Document ID\"] || item.json.DocumentID || item.json.documentId || null;\n  const url = item.json.URL || item.json.url || null;\n  const contentHint = item.json.contentHint || null;\n  const isSingleUseCase = item.json.isSingleUseCase ?? null;\n  const isRelevant = item.json.isRelevant ?? null;\n  const shouldProcess = item.json.shouldProcess ?? null;\n  const determinedAs = item.json.debug?.determinedAs || null;\n\n  if (!groups[key]) {\n    groups[key] = {\n      paragraphs: [],\n      use_cases: [],\n      references: [],\n      debug: [],\n      Title: title,\n      DocumentID: docId,\n      URL: url,\n      contentHint,\n      isSingleUseCase,\n      isRelevant,\n      shouldProcess,\n      determinedAs   // ✅ flatten to root\n    };\n  }\n\n  // Each LLM batch output should already follow the 3-section format\n  const msg = item.json.message || \"\";\n\n  // Extract sections via regex\n  const paraMatch = msg.match(/=== PARAGRAPHS \\/ CONTEXT ===([\\s\\S]*?)(?=== USE CASES START BELOW ===)/);\n  const useCaseMatch = msg.match(/=== USE CASES START BELOW ===([\\s\\S]*?)(?=== REFERENCES \\/ SOURCES ===)/);\n  const refMatch = msg.match(/=== REFERENCES \\/ SOURCES ===([\\s\\S]*)/);\n\n  if (paraMatch && paraMatch[1].trim() && paraMatch[1].trim() !== \"None\") {\n    groups[key].paragraphs.push(paraMatch[1].trim());\n  }\n  if (useCaseMatch && useCaseMatch[1].trim() && useCaseMatch[1].trim() !== \"None\") {\n    groups[key].use_cases.push(useCaseMatch[1].trim());\n  }\n  if (refMatch && refMatch[1].trim() && refMatch[1].trim() !== \"None\") {\n    groups[key].references.push(refMatch[1].trim());\n  }\n\n  groups[key].debug.push({\n    index: item.json.BatchIndex,\n    rawLength: (item.json.Content || \"\").length\n  });\n\n  // ✅ If later items contain non-null metadata, prefer them\n  if (!groups[key].Title && title) groups[key].Title = title;\n  if (!groups[key].DocumentID && docId) groups[key].DocumentID = docId;\n  if (!groups[key].URL && url) groups[key].URL = url;\n  if (!groups[key].contentHint && contentHint) groups[key].contentHint = contentHint;\n  if (groups[key].isSingleUseCase === null && isSingleUseCase !== null) groups[key].isSingleUseCase = isSingleUseCase;\n  if (groups[key].isRelevant === null && isRelevant !== null) groups[key].isRelevant = isRelevant;\n  if (groups[key].shouldProcess === null && shouldProcess !== null) groups[key].shouldProcess = shouldProcess;\n  if (!groups[key].determinedAs && determinedAs) groups[key].determinedAs = determinedAs;\n}\n\n// Final combined output\nreturn Object.entries(groups).map(([key, group]) => {\n  // Deduplicate references\n  const dedupedRefs = [...new Set(group.references.join(\"\\n\").split(/\\n+/))].filter(r => r.trim());\n\n  return {\n    json: {\n      GroupKey: key,\n      Title: group.Title || null,\n      DocumentID: group.DocumentID || null,\n      URL: group.URL || null,\n      contentHint: group.contentHint || null,\n      isSingleUseCase: group.isSingleUseCase,\n      isRelevant: group.isRelevant,\n      shouldProcess: group.shouldProcess,\n      determinedAs: group.determinedAs || null,   // ✅ flattened\n      FinalOutput:\n        \"=== PARAGRAPHS / CONTEXT ===\\n\" +\n        (group.paragraphs.length ? group.paragraphs.join(\"\\n\\n\") : \"None\") +\n        \"\\n\\n=== USE CASES START BELOW ===\\n\" +\n        (group.use_cases.length ? group.use_cases.join(\"\\n\\n\") : \"None\") +\n        \"\\n\\n=== REFERENCES / SOURCES ===\\n\" +\n        (dedupedRefs.length ? dedupedRefs.join(\"\\n\") : \"None\"),\n      DebugInfo: group.debug\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        384
      ],
      "id": "afd8e08f-6023-4e23-a12b-b8e3904aebc4",
      "name": "Combine"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1248,
        384
      ],
      "id": "51d11087-ea50-46ae-9634-ff6f1b99998c",
      "name": "Merge"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 157514600,
          "mode": "list",
          "cachedResultName": "Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=157514600"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        6480,
        352
      ],
      "id": "5257120d-ff23-4b45-8c31-f15f4f908875",
      "name": "Get Document URL"
    },
    {
      "parameters": {
        "operation": "get",
        "documentURL": "={{ $json[\"Document ID\"] }}"
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        7440,
        352
      ],
      "id": "09f6608a-093b-43e6-a046-a392da7adf24",
      "name": "Get document"
    },
    {
      "parameters": {
        "jsCode": "// Structured Output\n// - Consumes deduped items + one control item with highestIdNum and url\n// - Assigns incremental Ids (UC{n})\n// - Sets References = controlUrl\n// - Normalizes Other_References with fallback to controlUrl\n// - Adds Timestamp\n\nconst toStr = v => (v == null ? \"\" : String(v));\nconst normalizeRefs = v => Array.isArray(v)\n  ? v.map(x => toStr(x).trim()).filter(Boolean).join(\"; \")\n  : toStr(v).trim();\n\nconst getIST = () => {\n  const ist = new Date(Date.now() + 5.5 * 3600 * 1000);\n  const y = ist.getUTCFullYear();\n  const m = String(ist.getUTCMonth() + 1).padStart(2, \"0\");\n  const d = String(ist.getUTCDate()).padStart(2, \"0\");\n  const hh = String(ist.getUTCHours()).padStart(2, \"0\");\n  const mm = String(ist.getUTCMinutes()).padStart(2, \"0\");\n  const ss = String(ist.getUTCSeconds()).padStart(2, \"0\");\n  return `'${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n};\n\n// Identify control item\nlet highestIdNum = 0;\nlet controlUrl = \"\";\nfor (const it of $items()) {\n  const j = it.json || {};\n  if (j.highestIdNum != null || j.nextIdNum != null || j.url != null || j.URL != null) {\n    const n = parseInt(j.highestIdNum ?? j.nextIdNum ?? \"0\", 10);\n    highestIdNum = Number.isNaN(n) ? 0 : n;\n    controlUrl = toStr(j.url ?? j.URL).trim();\n    break;\n  }\n}\n\nconst prefix = \"UC\";\nlet counter = highestIdNum + 1;\n\n// Collect only use case items (filter out control item)\nconst data = $items()\n  .map(it => it.json)\n  .filter(j => j && j.Industry && j.Title_Of_AI_Use_Case && !(\"highestIdNum\" in j) && !(\"nextIdNum\" in j));\n\n// Map rows\nconst out = data.map(u => {\n  const otherRefsNormalized = normalizeRefs(\n    u.Other_References ?? u.OtherReferences ?? u[\"Other References\"] ?? u.References ?? \"\"\n  ) || controlUrl;\n\n  return {\n    json: {\n      Id: `${prefix}${counter++}`,\n      Industry: toStr(u.Industry),\n      Subindustry: toStr(u.Subindustry),\n      Business_Function: toStr(u.Business_Function),\n      Business_Capability: toStr(u.Business_Capability),\n      Stakeholder_Or_User: toStr(u.Stakeholder_Or_User),\n      Title_Of_AI_Use_Case: toStr(u.Title_Of_AI_Use_Case),\n      Description: toStr(u.Description),\n      Impact: toStr(u.Impact),\n      Action_Implementation_Plan: toStr(u.Action_Implementation_Plan),\n      Expected_Outcomes_And_Results: toStr(u.Expected_Outcomes_And_Results),\n      Datasets: toStr(u.Datasets),\n      AI_Capabilities_And_Tech: toStr(u.AI_Capabilities_And_Tech),\n      Digital_Platforms_And_Tools: toStr(u.Digital_Platforms_And_Tools),\n      AI_Algo_And_Frameworks: toStr(u.AI_Algo_And_Frameworks),\n      Tools_And_Models: toStr(u.Tools_And_Models),\n      References: controlUrl,\n      Other_References: otherRefsNormalized,\n      Timestamp: getIST()\n    }\n  };\n});\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7824,
        608
      ],
      "id": "59cd529c-0dcd-4c94-a810-081819c1555d",
      "name": "Structured Output",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k",
          "mode": "list",
          "cachedResultName": "AI_Use_cases_Perplexity",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 314402473,
          "mode": "list",
          "cachedResultName": "Perplexity LLM Generated Output Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit#gid=314402473"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Id": "={{ $json.Id }}",
            "Industry": "={{ $json.Industry }}",
            "Subindustry": "={{ $json.Subindustry }}",
            "Business_Function": "={{ $json.Business_Function }}",
            "Business_Capability": "={{ $json.Business_Capability }}",
            "Stakeholder_Or_User": "={{ $json.Stakeholder_Or_User }}",
            "Description": "={{ $json.Description }}",
            "Impact": "={{ $json.Impact }}",
            "Action_Implementation_Plan": "={{ $json.Action_Implementation_Plan }}",
            "Expected_Outcomes_And_Results": "={{ $json.Expected_Outcomes_And_Results }}",
            "Datasets": "={{ $json.Datasets }}",
            "Digital_Platforms_And_Tools": "={{ $json.Digital_Platforms_And_Tools }}",
            "Tools_And_Models": "={{ $json.Tools_And_Models }}",
            "Timestamp": "={{ $json.Timestamp }}",
            "References": "={{ $json.References }}",
            "AI_Algo_And_Frameworks": "={{ $json.AI_Algo_And_Frameworks }}",
            "AI_Capabilities_And_Tech": "={{ $json.AI_Capabilities_And_Tech }}",
            "Title_Of_AI_Use_Case": "={{ $json.Title_Of_AI_Use_Case }}",
            "Other_References": "={{ $json.Other_References }}"
          },
          "matchingColumns": [
            "Id"
          ],
          "schema": [
            {
              "id": "Id",
              "displayName": "Id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Industry",
              "displayName": "Industry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Subindustry",
              "displayName": "Subindustry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Business_Function",
              "displayName": "Business_Function",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Business_Capability",
              "displayName": "Business_Capability",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Stakeholder_Or_User",
              "displayName": "Stakeholder_Or_User",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Title_Of_AI_Use_Case",
              "displayName": "Title_Of_AI_Use_Case",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Description",
              "displayName": "Description",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Impact",
              "displayName": "Impact",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Action_Implementation_Plan",
              "displayName": "Action_Implementation_Plan",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Expected_Outcomes_And_Results",
              "displayName": "Expected_Outcomes_And_Results",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Datasets",
              "displayName": "Datasets",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "AI_Capabilities_And_Tech",
              "displayName": "AI_Capabilities_And_Tech",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Digital_Platforms_And_Tools",
              "displayName": "Digital_Platforms_And_Tools",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "AI_Algo_And_Frameworks",
              "displayName": "AI_Algo_And_Frameworks",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Tools_And_Models",
              "displayName": "Tools_And_Models",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "References",
              "displayName": "References",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Other_References",
              "displayName": "Other_References",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Timestamp",
              "displayName": "Timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        8000,
        608
      ],
      "id": "6e72cc14-d978-49b2-917f-2f2557b035c6",
      "name": "Store the Output"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k",
          "mode": "list",
          "cachedResultName": "AI_Use_cases_Perplexity",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 314402473,
          "mode": "list",
          "cachedResultName": "Perplexity LLM Generated Output Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit#gid=314402473"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        6480,
        608
      ],
      "id": "98c7d458-2d47-40bf-b226-c7f5385ab1d4",
      "name": "Get ID"
    },
    {
      "parameters": {
        "content": "## Getting Output From Scraped Data LLM Generated output",
        "height": 656,
        "width": 3568,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        6192,
        176
      ],
      "id": "f0ebf955-1bd7-483e-8b6e-dd153f6fd3e5",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "1b63c677-ce12-48ea-9d25-701fb30a5b98",
              "leftValue": "={{ $json[\"Generated Output\"] }}",
              "rightValue": " No",
              "operator": {
                "type": "string",
                "operation": "empty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        6656,
        352
      ],
      "id": "28e66ce3-2db5-4137-b9da-8c6155de7679",
      "name": "If"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "6e9612d3-1d33-4252-8978-53c54663689c",
              "name": "url",
              "value": "={{ $json.url }}",
              "type": "string"
            },
            {
              "id": "912b10d3-fcb4-442c-ba52-b89ec175a0eb",
              "name": "highestIdNum",
              "value": "={{ $json.highestIdNum }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        7424,
        624
      ],
      "id": "efa663be-b2ef-4cca-9701-d70d8166e200",
      "name": "Set Id and URL"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        6848,
        336
      ],
      "id": "8a798f0c-7877-4af1-9e73-f5902d5fd09f",
      "name": "Limit"
    },
    {
      "parameters": {
        "keep": "lastItems"
      },
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        8240,
        608
      ],
      "id": "0f9d34e5-48f8-4423-ae75-8c8c211eafb2",
      "name": "Limit4"
    },
    {
      "parameters": {
        "jsCode": "// Smart Document Chunker with Use Case Boundary Awareness\nconst CHUNK_SIZE = 4000; // Slightly smaller chunks for better precision\nconst OVERLAP = 300;     // Increased overlap to catch split use cases\n\nfunction createSmartChunks(text, documentId) {\n    if (!text || text.length < 500) {\n        return [{ content: text, isShort: true }];\n    }\n\n    console.log(`Creating chunks for document ${documentId}, length: ${text.length}`);\n    \n    const chunks = [];\n    let start = 0;\n    \n    // First, try to split at natural boundaries\n    const naturalBoundaries = [\n        /\\n\\s*\\d+[\\.\\)]\\s+/g,    // Numbered lists: \"1. \", \"2) \"\n        /\\n\\s*[a-zA-Z][\\.\\)]\\s+/g, // Lettered lists: \"A. \", \"b) \"\n        /\\n\\s*[•\\-*]\\s+/g,       // Bullet points\n        /\\n\\s*#{1,4}\\s+/g,       // Headers: \"# \", \"## \"\n        /\\n\\s*[A-Z][^\\\\n]{10,}:\\s*\\n/g, // Section headers ending with colon\n    ];\n    \n    while (start < text.length) {\n        const chunkEnd = Math.min(start + CHUNK_SIZE, text.length);\n        \n        if (chunkEnd >= text.length) {\n            // Last chunk\n            const content = text.slice(start).trim();\n            if (content.length > 100) {\n                chunks.push({ content, isLast: true });\n            }\n            break;\n        }\n        \n        // Look for the best split point near the ideal chunk end\n        let splitPoint = chunkEnd;\n        let bestBoundary = -1;\n        \n        for (const pattern of naturalBoundaries) {\n            pattern.lastIndex = start + (CHUNK_SIZE * 0.7); // Start looking in last 30%\n            const match = pattern.exec(text);\n            \n            if (match && match.index > start + (CHUNK_SIZE * 0.5) && match.index < chunkEnd) {\n                if (bestBoundary === -1 || match.index > bestBoundary) {\n                    bestBoundary = match.index;\n                }\n            }\n        }\n        \n        if (bestBoundary !== -1) {\n            splitPoint = bestBoundary;\n        } else {\n            // Fallback: split at sentence boundary near chunk end\n            const sentenceBoundary = text.slice(start, chunkEnd).lastIndexOf('. ');\n            if (sentenceBoundary !== -1 && sentenceBoundary > CHUNK_SIZE * 0.6) {\n                splitPoint = start + sentenceBoundary + 1;\n            }\n        }\n        \n        const chunkContent = text.slice(start, splitPoint).trim();\n        if (chunkContent.length > 200) {\n            chunks.push({ content: chunkContent });\n        }\n        \n        // Next chunk starts with overlap to prevent missing content\n        start = Math.max(splitPoint - OVERLAP, start + (CHUNK_SIZE * 0.8));\n    }\n    \n    console.log(`Created ${chunks.length} chunks with smart boundaries`);\n    return chunks;\n}\n\n// Main execution\nconst outputItems = [];\n\nfor (const item of $input.all()) {\n    const documentContent = item.json?.content || \"\";\n    const documentId = item.json?.documentId || \"\";\n    \n    if (!documentContent) {\n        console.log(\"No content to chunk\");\n        continue;\n    }\n    \n    const chunks = createSmartChunks(documentContent, documentId);\n    \n    chunks.forEach((chunk, index) => {\n        outputItems.push({\n            json: {\n                content: chunk.content,\n                chunk_index: index,\n                total_chunks: chunks.length,\n                documentId: documentId,\n                isShort: chunk.isShort || false,\n                isLast: chunk.isLast || false\n            }\n        });\n    });\n}\n\nconsole.log(`Total chunks created: ${outputItems.length}`);\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7792,
        352
      ],
      "id": "50524204-76d5-4056-a95b-ccf800a85128",
      "name": "Chunk Document"
    },
    {
      "parameters": {
        "jsCode": "// Aggressive Semantic Deduplication - Merges use cases that are functionally identical\n\nfunction normalizeForComparison(str) {\n  return (str || \"\")\n    .toLowerCase()\n    .normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\") // remove accents\n    .replace(/[^a-z0-9\\s]/g, \" \") // replace punctuation with space\n    .replace(/\\s+/g, \" \") // collapse multiple spaces\n    .trim();\n}\n\nfunction createSemanticFingerprint(useCase) {\n  // Creates a fingerprint based on the CORE of the use case, ignoring fluff words\n  const coreString = `\n    ${useCase.Industry || \"\"}\n    ${useCase.Business_Function || \"\"}\n    ${useCase.Title_Of_AI_Use_Case || \"\"}\n    ${useCase.AI_Capabilities_And_Tech || \"\"}\n  `;\n\n  const normalized = normalizeForComparison(coreString);\n\n  // Remove very common words that don't define uniqueness\n  const stopWords = new Set([\n    \"the\", \"and\", \"for\", \"with\", \"using\", \"via\", \"of\", \"in\", \"a\", \"an\",\n    \"this\", \"that\", \"powered\", \"driven\", \"based\", \"ai\", \"ml\",\n    \"machine\", \"learning\", \"intelligence\", \"artificial\"\n  ]);\n\n  const meaningfulWords = normalized\n    .split(\" \")\n    .filter(word => word.length > 3 && !stopWords.has(word));\n\n  // Sort and join to create a consistent fingerprint regardless of word order\n  return meaningfulWords.sort().join(\" \");\n}\n\nfunction areUseCasesDuplicates(uc1, uc2) {\n  const fingerprint1 = createSemanticFingerprint(uc1);\n  const fingerprint2 = createSemanticFingerprint(uc2);\n\n  // If fingerprints are identical, they are duplicates\n  if (fingerprint1 === fingerprint2 && fingerprint1.length > 10) {\n    return true;\n  }\n\n  // If titles are very similar, they are duplicates\n  const title1 = normalizeForComparison(uc1.Title_Of_AI_Use_Case);\n  const title2 = normalizeForComparison(uc2.Title_Of_AI_Use_Case);\n\n  if (title1.length > 20 && title2.length > 20) {\n    // Check if one title is contained within the other\n    if (title1.includes(title2) || title2.includes(title1)) {\n      return true;\n    }\n\n    // Simple Levenshtein distance approximation (90% similarity)\n    const longer = Math.max(title1.length, title2.length);\n    const distance = levenshteinDistance(title1, title2);\n\n    if (distance / longer < 0.15) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Helper function for string similarity (Levenshtein Distance)\nfunction levenshteinDistance(a, b) {\n  const an = a ? a.length : 0;\n  const bn = b ? b.length : 0;\n  if (an === 0) return bn;\n  if (bn === 0) return an;\n\n  const matrix = new Array(bn + 1);\n  for (let i = 0; i <= bn; ++i) matrix[i] = new Array(an + 1);\n\n  for (let i = 0; i <= bn; ++i) matrix[i][0] = i;\n  for (let j = 0; j <= an; ++j) matrix[0][j] = j;\n\n  for (let i = 1; i <= bn; ++i) {\n    for (let j = 1; j <= an; ++j) {\n      const cost = a[j - 1] === b[i - 1] ? 0 : 1;\n      matrix[i][j] = Math.min(\n        matrix[i - 1][j] + 1,\n        matrix[i][j - 1] + 1,\n        matrix[i - 1][j - 1] + cost\n      );\n    }\n  }\n  return matrix[bn][an];\n}\n\nfunction selectBestUseCase(useCaseA, useCaseB) {\n  // Prefer the use case with the longer, more detailed description\n  const descLengthA = (useCaseA.Description || \"\").length;\n  const descLengthB = (useCaseB.Description || \"\").length;\n\n  if (descLengthB > descLengthA) {\n    return useCaseB;\n  }\n  return useCaseA; // Default to A if equal\n}\n\nfunction isChunkBoundaryDuplicate(uc1, uc2) {\n    // Check if these are the same use case from adjacent chunks\n    const sameDocument = uc1._documentId === uc2._documentId;\n    const adjacentChunks = Math.abs((uc1._chunk_index || 0) - (uc2._chunk_index || 0)) === 1;\n    \n    if (sameDocument && adjacentChunks) {\n        const titleSimilarity = stringSimilarity(\n            uc1.Title_Of_AI_Use_Case || '',\n            uc2.Title_Of_AI_Use_Case || ''\n        );\n        \n        // If titles are very similar and from adjacent chunks, likely same use case\n        return titleSimilarity > 0.7;\n    }\n    return false;\n}\n\nfunction stringSimilarity(str1, str2) {\n    const longer = str1.length > str2.length ? str1 : str2;\n    const shorter = str1.length > str2.length ? str2 : str1;\n    \n    if (longer.length === 0) return 1.0;\n    \n    return (longer.length - editDistance(longer, shorter)) / parseFloat(longer.length);\n}\n\nfunction editDistance(s1, s2) {\n    s1 = s1.toLowerCase();\n    s2 = s2.toLowerCase();\n    \n    const costs = [];\n    for (let i = 0; i <= s1.length; i++) {\n        let lastValue = i;\n        for (let j = 0; j <= s2.length; j++) {\n            if (i === 0) costs[j] = j;\n            else {\n                if (j > 0) {\n                    let newValue = costs[j - 1];\n                    if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {\n                        newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;\n                    }\n                    costs[j - 1] = lastValue;\n                    lastValue = newValue;\n                }\n            }\n        }\n        if (i > 0) costs[s2.length] = lastValue;\n    }\n    return costs[s2.length];\n}\n// Main Deduplication Logic\nconst inputItems = $input.all().map(item => item.json).filter(uc => uc != null);\nconst uniqueUseCases = [];\n\nconsole.log(`Starting deduplication on ${inputItems.length} items.`);\n\nfor (const currentUseCase of inputItems) {\n  let isDuplicate = false;\n\n  for (let i = 0; i < uniqueUseCases.length; i++) {\n    if (areUseCasesDuplicates(currentUseCase, uniqueUseCases[i]) || \n        isChunkBoundaryDuplicate(currentUseCase, uniqueUseCases[i])) { \n      console.log(\n        `🔄 Merging duplicate: \"${currentUseCase.Title_Of_AI_Use_Case}\" into \"${uniqueUseCases[i].Title_Of_AI_Use_Case}\"`\n      );\n      uniqueUseCases[i] = selectBestUseCase(uniqueUseCases[i], currentUseCase);\n      isDuplicate = true;\n      break;\n    }\n  }\n\n  if (!isDuplicate) {\n    uniqueUseCases.push(currentUseCase);\n  }\n}\n\nconsole.log(\n  `Deduplication complete. ${inputItems.length} -> ${uniqueUseCases.length} unique use cases.`\n);\n\nreturn uniqueUseCases.map(uc => ({ json: uc }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9488,
        624
      ],
      "id": "954f48d3-705c-41ee-8a3a-3621777fab40",
      "name": "Final Deduplication1"
    },
    {
      "parameters": {
        "jsCode": "// This ensures the loop continues even if individual API calls fail\n\nconst input = $input.all();\n\n// Check if we have valid data\nif (!input || input.length === 0) {\n  console.log(\"No input data - returning empty result to continue loop\");\n  return [{\n    json: {\n      message: \"[]\", // Empty JSON array for downstream processing\n      chunk_index: $json?.chunk_index || 0,\n      documentId: $json?.documentId || \"\",\n      content: $json?.content || \"\"\n    }\n  }];\n}\n\n// Check if the API response is valid\nconst firstItem = input[0];\nif (!firstItem.json?.message) {\n  console.log(\"Invalid API response - returning empty result\");\n  return [{\n    json: {\n      message: \"[]\",\n      chunk_index: firstItem.json?.chunk_index || 0,\n      documentId: firstItem.json?.documentId || \"\",\n      content: firstItem.json?.content || \"\"\n    }\n  }];\n}\n\n// Return the original data if valid\nreturn input;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8592,
        224
      ],
      "id": "372ec8db-6dce-4893-8c7d-36711d2a604c",
      "name": "Error Handler Node"
    },
    {
      "parameters": {
        "jsCode": "// Simple Accumulator - Just collect and pass through\nconst allItems = $input.all();\nconsole.log(`Accumulator: ${allItems.length} items received`);\n\n// Just return everything - let downstream nodes handle processing\nreturn allItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9312,
        624
      ],
      "id": "ef7ee4e9-4d6d-402b-81c3-03c813456a8d",
      "name": "Accumulator Node"
    },
    {
      "parameters": {
        "jsCode": "// Smart Context-Aware Validation - Only fills missing fields when truly necessary\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\nconst hasValue = v => toStr(v).length > 0;\n\n// Minimum lengths for critical fields\nconst MINIMUM_LENGTHS = {\n  Title_Of_AI_Use_Case: 5,  // Reduced to avoid over-creation\n  Description: 25,           // Reduced threshold\n  Impact: 15\n};\n\n// Industry-specific tool and technology mappings\nconst INDUSTRY_SPECIFICS = {\n  healthcare: {\n    tools: ['medical imaging software', 'patient data platform', 'clinical decision support system'],\n    algorithms: ['computer vision', 'predictive analytics', 'natural language processing'],\n    datasets: ['medical images', 'patient records', 'clinical trial data']\n  },\n  finance: {\n    tools: ['fraud detection platform', 'risk analytics software', 'algorithmic trading system'],\n    algorithms: ['anomaly detection', 'time series analysis', 'reinforcement learning'],\n    datasets: ['transaction records', 'market data', 'credit histories']\n  },\n  retail: {\n    tools: ['recommendation engine', 'inventory management system', 'customer analytics platform'],\n    algorithms: ['collaborative filtering', 'demand forecasting', 'customer segmentation'],\n    datasets: ['purchase history', 'browsing behavior', 'inventory levels']\n  },\n  manufacturing: {\n    tools: ['predictive maintenance platform', 'quality control system', 'supply chain optimizer'],\n    algorithms: ['computer vision', 'time series forecasting', 'optimization algorithms'],\n    datasets: ['sensor data', 'production logs', 'quality metrics']\n  },\n  default: {\n    tools: ['data analytics platform', 'machine learning framework'],\n    algorithms: ['machine learning algorithms', 'pattern recognition'],\n    datasets: ['historical data', 'user behavior data']\n  }\n};\n\nfunction extractSpecificTerms(text, category) {\n  // Extract specific technologies mentioned in the text\n  const patterns = {\n    tools: /\\b(tensorflow|pytorch|scikit-learn|opencv|keras|spark|hadoop|aws|azure|gcp|snowflake|databricks|tableau|powerbi)\\b/gi,\n    algorithms: /\\b(computer vision|natural language processing|nlp|reinforcement learning|deep learning|neural networks|random forest|svm|clustering|regression|classification)\\b/gi,\n    datasets: /\\b(historical data|transaction data|user data|sensor data|image data|text data|log data|real-time data)\\b/gi\n  };\n  \n  const matches = [];\n  let match;\n  const pattern = patterns[category];\n  \n  if (pattern) {\n    pattern.lastIndex = 0;\n    while ((match = pattern.exec(text)) !== null) {\n      if (!matches.includes(match[0].toLowerCase())) {\n        matches.push(match[0].toLowerCase());\n      }\n    }\n  }\n  \n  return matches;\n}\n\nfunction getContextualDefaults(useCase, context) {\n  const contextLower = context.toLowerCase();\n  \n  // Determine industry from context or use case\n  let industry = 'default';\n  const industries = Object.keys(INDUSTRY_SPECIFICS);\n  for (const ind of industries) {\n    if (ind !== 'default' && contextLower.includes(ind)) {\n      industry = ind;\n      break;\n    }\n  }\n  \n  const specifics = INDUSTRY_SPECIFICS[industry] || INDUSTRY_SPECIFICS.default;\n  \n  // Extract specific terms mentioned in the context\n  const mentionedTools = extractSpecificTerms(context, 'tools');\n  const mentionedAlgorithms = extractSpecificTerms(context, 'algorithms');\n  const mentionedDatasets = extractSpecificTerms(context, 'datasets');\n  \n  return {\n    tools: mentionedTools.length > 0 ? mentionedTools.join(', ') : specifics.tools[0],\n    algorithms: mentionedAlgorithms.length > 0 ? mentionedAlgorithms.join(', ') : specifics.algorithms[0],\n    datasets: mentionedDatasets.length > 0 ? mentionedDatasets.join(', ') : specifics.datasets[0],\n    platforms: mentionedTools.length > 0 ? mentionedTools.join(', ') : 'cloud computing platform'\n  };\n}\n\nfunction shouldEnrichField(currentValue, minLength) {\n  // Only enrich if field is empty or very short\n  return !hasValue(currentValue) || toStr(currentValue).length < (minLength || 5);\n}\n\nfunction smartEnrichUseCase(useCase, context) {\n  const enriched = { ...useCase };\n  const defaults = getContextualDefaults(useCase, context);\n  \n  // Only enrich if absolutely necessary\n  if (shouldEnrichField(enriched.Digital_Platforms_And_Tools)) {\n    enriched.Digital_Platforms_And_Tools = defaults.platforms;\n  }\n  \n  if (shouldEnrichField(enriched.AI_Algo_And_Frameworks)) {\n    enriched.AI_Algo_And_Frameworks = defaults.algorithms;\n  }\n  \n  if (shouldEnrichField(enriched.Tools_And_Models)) {\n    enriched.Tools_And_Models = defaults.tools;\n  }\n  \n  if (shouldEnrichField(enriched.Datasets)) {\n    enriched.Datasets = defaults.datasets;\n  }\n  \n  // Only add generic description if it's very short\n  if (shouldEnrichField(enriched.Description, MINIMUM_LENGTHS.Description)) {\n    const businessFunc = enriched.Business_Function || 'business operations';\n    enriched.Description = `${enriched.Description || 'AI-powered solution'} for ${businessFunc}.`.trim();\n  }\n  \n  // Only add generic impact if empty\n  if (shouldEnrichField(enriched.Impact, MINIMUM_LENGTHS.Impact)) {\n    enriched.Impact = 'Improves efficiency and decision-making';\n  }\n  \n  return enriched;\n}\n\nfunction isMinimumViableUseCase(useCase) {\n  return hasValue(useCase.Title_Of_AI_Use_Case) && \n         hasValue(useCase.Description) &&\n         toStr(useCase.Title_Of_AI_Use_Case).length >= MINIMUM_LENGTHS.Title_Of_AI_Use_Case &&\n         toStr(useCase.Description).length >= MINIMUM_LENGTHS.Description;\n}\n\n// Main processing\nconst results = [];\nlet processedCount = 0;\nlet enrichedCount = 0;\nlet skippedCount = 0;\n\nfor (const item of $input.all()) {\n  const useCase = item.json;\n  processedCount++;\n  \n  // Skip items that don't look like use cases at all\n  if (!useCase || !useCase.Title_Of_AI_Use_Case) {\n    console.log(\"Skipping item without title\");\n    skippedCount++;\n    continue;\n  }\n  \n  // Get original content for context\n  const originalContent = useCase.filtered_content || useCase.content || useCase._chunk_content || '';\n  \n  // Smart enrichment - only fill what's absolutely necessary\n  const enrichedUseCase = smartEnrichUseCase(useCase, originalContent);\n  \n  // Check if this is a minimum viable use case\n  if (isMinimumViableUseCase(enrichedUseCase)) {\n    // Clean up metadata fields\n    const cleanUseCase = { ...enrichedUseCase };\n    delete cleanUseCase.filtered_content;\n    delete cleanUseCase._chunk_content;\n    delete cleanUseCase._chunk_index;\n    delete cleanUseCase._document_id;\n    delete cleanUseCase.has_use_cases;\n    delete cleanUseCase.original_length;\n    delete cleanUseCase.filtered_length;\n    \n    results.push({ json: cleanUseCase });\n    enrichedCount++;\n    \n    // Log what was enriched\n    const enrichedFields = [];\n    if (useCase.Digital_Platforms_And_Tools !== enrichedUseCase.Digital_Platforms_And_Tools) enrichedFields.push('Tools');\n    if (useCase.AI_Algo_And_Frameworks !== enrichedUseCase.AI_Algo_And_Frameworks) enrichedFields.push('Algorithms');\n    if (useCase.Tools_And_Models !== enrichedUseCase.Tools_And_Models) enrichedFields.push('Models');\n    \n    if (enrichedFields.length > 0) {\n      console.log(`✓ Enriched [${enrichedFields.join(', ')}] for: ${enrichedUseCase.Title_Of_AI_Use_Case}`);\n    } else {\n      console.log(`✓ Pass-through: ${enrichedUseCase.Title_Of_AI_Use_Case}`);\n    }\n  } else {\n    console.log(`✗ Insufficient data: ${useCase.Title_Of_AI_Use_Case || 'No title'}`);\n    skippedCount++;\n  }\n}\n\nconsole.log(`\\nValidation Results:`);\nconsole.log(`  Processed: ${processedCount}`);\nconsole.log(`  Enriched & Passed: ${enrichedCount}`);\nconsole.log(`  Skipped: ${skippedCount}`);\nconsole.log(`  Success Rate: ${((enrichedCount / processedCount) * 100).toFixed(1)}%`);\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9136,
        624
      ],
      "id": "2352a613-05a4-4ccb-9667-57ce6327727e",
      "name": "Validation"
    },
    {
      "parameters": {
        "jsCode": "// Universal Smart Gatekeeper - Catches ALL common use case formats\nconsole.log(\"=== Universal Smart Gatekeeper ===\");\n\n// BROAD, INCLUSIVE PATTERNS - Designed to catch 99% of use case formats\nconst UNIVERSAL_INDICATORS = [\n    // 1. Numbered lists (1., 2., 3. OR 1), 2), 3) OR (1), (2), (3))\n    /(?:^|\\n)\\s*\\(?\\d+[\\.\\)]\\s+.{15,}?(?:ai|artificial intelligence|machine learning|ml|automation|optimization|prediction|detection)/gi,\n    \n    // 2. Lettered lists (A., B., C. OR a), b), c) OR (a), (b), (c))\n    /(?:^|\\n)\\s*\\(?[A-Za-z][\\.\\)]\\s+.{15,}?(?:ai|artificial intelligence|machine learning|ml)/gi,\n    \n    // 3. Bullet points (•, -, *, —)\n    /(?:^|\\n)\\s*[•\\-*—]\\s+.{15,}?(?:ai|artificial intelligence|machine learning|ml|using|for|to)/gi,\n    \n    // 4. Section headers with colons (Use Cases:, Applications:, Examples:)\n    /(?:^|\\n)\\s*.*?(?:use cases?|applications?|examples?|implementations?):\\s*.{10,}/gi,\n    \n    // 5. ANY text that contains both AI keywords AND action verbs\n    /(?:^|\\n)\\s*.*?\\b(?:ai|artificial intelligence|machine learning|ml)\\b.*?\\b(?:for|to|in|using|via|through|enables?|automates?|optimizes?|predicts?|detects?|enhances?|improves?)\\b.{20,}/gi,\n    \n    // 6. Pattern: \"[Use Case Description]. [AI Technology] can [do something]\"\n    /\\.\\s*[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\s+(?:can|is used to|helps|enables).{20,}?(?:ai|artificial intelligence|machine learning|ml)/gi,\n    // 7. \"Opportunity:\" format (NEW)\n    /(?:^|\\n)\\s*Opportunity:\\s+.{20,}?(?:ai|artificial intelligence|machine learning|ml|automation)/gi,\n    /(?:^|\\n)\\s*Solution:\\s+.{20,}?(?:ai|artificial intelligence|machine learning|ml)/gi,\n    /(?:^|\\n)\\s*Use Case:\\s+.{20,}?(?:ai|artificial intelligence|machine learning|ml)/gi,\n    \n    // 8. Key-value pair formats\n    /(?:^|\\n)\\s*(?:Application|Implementation|Scenario|Potential):\\s+.{15,}/gi,\n    \n    // 9. Section headers without colons\n    /(?:^|\\n)\\s*#+\\s*(AI Use Cases|Applications|Implementations).{10,}/gi\n];\n\n\n// ENHANCED GATEKEEPER FUNCTION\nfunction chunkHasUseCases(text) {\n    if (!text || text.length < 100) {\n        console.log(\"❌ Text too short\");\n        return false;\n    }\n\n    console.log(`📄 Analyzing chunk (${text.length} chars)...`);\n    \n    // Test ALL universal patterns\n    for (const pattern of UNIVERSAL_INDICATORS) {\n        let match;\n        pattern.lastIndex = 0; // Reset regex state\n        \n        while ((match = pattern.exec(text)) !== null) {\n            const matchText = match[0].substring(0, 80).replace(/\\n/g, \" \");\n            console.log(`   ✅ FOUND: ${pattern.toString().substring(0,30)}... → \"${matchText}...\"`);\n            pattern.lastIndex = 0; // Reset after successful match\n            return true; // Return on FIRST match\n        }\n    }\n    \n    // If we get here, no patterns matched\n    console.log(\"   ❌ No universal patterns matched\");\n    \n    // ENHANCED FALLBACK: Also check for \"Opportunity\" without colon\n    const hasOpportunity = /opportunity\\s+.{20,}?ai/gi.test(text);\n    const hasAIPhrase = /ai|artificial intelligence|machine learning|ml/gi.test(text);\n    \n    if (hasOpportunity && hasAIPhrase) {\n        console.log(\"   ⚡ FALLBACK: Contains 'opportunity' and AI keywords - allowing through\");\n        return true;\n    }\n    \n    console.log(\"   🚫 No use case signals detected\");\n    return false;\n}\nfunction isLikelyTruncatedUseCase(text, chunkIndex, totalChunks) {\n    // Check if this might be the end of a use case that continues in next chunk\n    if (chunkIndex < totalChunks - 1) { // Not the last chunk\n        const endsWithColon = text.trim().endsWith(':');\n        const endsWithIncompleteList = /(\\d+\\.\\s*[^\\\\n]*$|[a-zA-Z]\\\\.\\\\s*[^\\\\n]*$)/.test(text);\n        const endsWithEllipsis = text.trim().endsWith('...');\n        \n        return endsWithColon || endsWithIncompleteList || endsWithEllipsis;\n    }\n    return false;\n}\n\n// MAIN EXECUTION\nlet outputItems = [];\nfor (const item of $input.all()) {\n    const originalContent = item.json?.content || \"\";\n    const documentId = item.json?.documentId || \"\";\n    const chunkIndex = item.json?.chunk_index || 0;\n    const totalChunks = item.json?.total_chunks || 1;\n\n    console.log(`\\n--- Chunk ${chunkIndex}/${totalChunks} ---`);\n    \n    const hasUseCases = chunkHasUseCases(originalContent);\n    const isTruncated = isLikelyTruncatedUseCase(originalContent, chunkIndex, totalChunks);\n    \n    if (hasUseCases) {\n        if (isTruncated) {\n            console.log(`⚠️  Chunk ${chunkIndex} has use cases BUT may be truncated - sending with warning`);\n            // You could add a flag here for the LLM\n        }\n        console.log(`✅ SENDING to LLM`);\n        outputItems.push(item);\n    } else {\n        if (isTruncated) {\n            console.log(`⚠️  Chunk ${chunkIndex} appears truncated but no patterns found - sending for safety`);\n            outputItems.push(item);\n        } else {\n            console.log(`➡️ SKIPPING (sending empty result)`);\n            outputItems.push({\n                json: {\n                    message: \"[]\",\n                    chunk_index: chunkIndex,\n                    documentId: documentId,\n                    total_chunks: totalChunks\n                }\n            });\n        }\n    }\n}\nconsole.log(`\\n🎯 Gatekeeper Results: ${outputItems.filter(item => item.json.content).length} chunks sent to LLM, ${outputItems.filter(item => item.json.message === \"[]\").length} skipped`);\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8000,
        352
      ],
      "id": "d13bba88-58dd-4a30-897a-66b3e6470557",
      "name": "Universal Smart Gatekeeper"
    },
    {
      "parameters": {
        "jsCode": "// Use case indicators (with variations and synonyms)\nconst USE_CASE_PATTERNS = [\n  /\\b(?:use\\s*cases?|applications?|examples?|scenarios?)\\b/gi,\n  /\\b(?:implementations?|solutions?|deployments?)\\b/gi,\n  /\\b(?:ai\\s*in\\s*\\w+|machine\\s*learning\\s*for|artificial\\s*intelligence\\s*in)\\b/gi,\n  /\\b(?:case\\s*study|real\\s*world\\s*example|practical\\s*application)\\b/gi,\n  /\\b(?:how\\s*ai\\s*helps|ai\\s*powered|ai\\s*enabled|ai\\s*driven)\\b/gi,\n  /\\b(?:\\d+\\.\\s*\\w+|\\w+\\.\\s*\\w+|step\\s*\\d+)\\b/gi, // numbered/lettered lists\n  /\\b(?:below\\s*are|following\\s*are|here\\s*are).*(?:use\\s*cases?|examples?|applications?)/gi\n];\n\n// Content sections to exclude\nconst EXCLUSION_PATTERNS = [\n  /\\b(?:about\\s*us|contact\\s*info|navigation|menu|footer|header)\\b/gi,\n  /\\b(?:references?|citations?|bibliography|footnotes?)\\b/gi,\n  /\\b(?:author|published|copyright|terms|privacy|legal)\\b/gi,\n  /\\b(?:subscribe|newsletter|follow\\s*us|social\\s*media)\\b/gi,\n  /\\b(?:related\\s*articles?|see\\s*also|further\\s*reading)\\b/gi\n];\n\nfunction hasUseCaseIndicators(text) {\n  if (!text || typeof text !== 'string') return false;\n  \n  const matchCount = USE_CASE_PATTERNS.reduce((count, pattern) => {\n    const matches = text.match(pattern) || [];\n    return count + matches.length;\n  }, 0);\n  \n  return matchCount >= 1; // At least one indicator\n}\n\nfunction isExcludedSection(text) {\n  if (!text || typeof text !== 'string') return true;\n  \n  return EXCLUSION_PATTERNS.some(pattern => pattern.test(text));\n}\n\nfunction analyzeContentStructure(text) {\n  const sections = text.split(/\\n\\s*\\n|\\n(?=[A-Z][^\\n]*:)|\\n(?=\\d+\\.)/);\n  \n  const analysis = sections.map((section, index) => ({\n    index,\n    text: section.trim(),\n    hasUseCases: hasUseCaseIndicators(section),\n    isExcluded: isExcludedSection(section),\n    wordCount: section.trim().split(/\\s+/).length,\n    hasStructure: /^(?:\\d+\\.|[A-Z]\\.|#{1,3}\\s|\\*\\s|\\-\\s)/.test(section.trim())\n  }));\n  \n  return analysis;\n}\n\nfunction filterRelevantContent(text) {\n  const analysis = analyzeContentStructure(text);\n  \n  const relevantSections = analysis.filter(section => \n    section.hasUseCases && \n    !section.isExcluded && \n    section.wordCount > 10\n  );\n  \n  if (relevantSections.length === 0) {\n    // Fallback: look for structured content that might contain use cases\n    const structuredSections = analysis.filter(section =>\n      section.hasStructure && \n      !section.isExcluded && \n      section.wordCount > 15 &&\n      /\\b(?:ai|artificial|intelligence|machine|learning|algorithm|data|automated|digital|smart|technology)\\b/gi.test(section.text)\n    );\n    \n    return structuredSections.map(s => s.text).join('\\n\\n');\n  }\n  \n  return relevantSections.map(s => s.text).join('\\n\\n');\n}\n\n// Main processing for each item\nconst results = [];\n\nfor (const item of $input.all()) {\n  const originalContent = item.json?.content || item.json?._chunk_content || \"\";\n  \n  if (!originalContent || originalContent.length < 50) {\n    console.log(\"Skipping item with insufficient content\");\n    continue;\n  }\n  \n  const relevantContent = filterRelevantContent(originalContent);\n  \n  if (!relevantContent || relevantContent.length < 100) {\n    console.log('No relevant use case content found in chunk');\n    continue;\n  }\n  \n  // Pass through the item with filtered content\n  results.push({\n    json: {\n      ...item.json,\n      filtered_content: relevantContent,\n      has_use_cases: true,\n      original_length: originalContent.length,\n      filtered_length: relevantContent.length\n    }\n  });\n  \n  console.log(`✓ Filtered content: ${originalContent.length} → ${relevantContent.length} chars`);\n}\n\nconsole.log(`Grounding filter: ${results.length}/${$input.all().length} items have relevant use case content`);\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8224,
        224
      ],
      "id": "2aad2e81-ae82-480e-8168-14c407536a09",
      "name": "Pre Grounding Filter"
    },
    {
      "parameters": {
        "jsCode": "// Balanced Grounding Filter - Catches hallucinations while preserving valid use cases\n// Uses multiple lightweight checks rather than heavy requirements\n\nconst toStr = v => (v == null ? \"\" : String(v));\nconst hasText = v => toStr(v).trim().length > 0;\n\nfunction norm(s) {\n  return toStr(s).toLowerCase().replace(/\\s+/g, \" \").trim();\n}\n\nfunction ensureString(x) {\n  if (Array.isArray(x)) return x.map(toStr).join(\", \");\n  if (x && typeof x === \"object\") return JSON.stringify(x);\n  return toStr(x);\n}\n\n// Simple but effective phrase matching\nfunction getKeyTerms(text) {\n  return norm(text).split(/\\s+/).filter(w => w.length > 3);\n}\n\n// Check if use case has basic grounding in source\nfunction hasBasicGrounding(item, chunk) {\n  const chunkNorm = norm(chunk);\n  \n  // 1. Title words check - at least 50% of significant title words should appear\n  const titleWords = getKeyTerms(ensureString(item.Title_Of_AI_Use_Case));\n  if (titleWords.length > 0) {\n    const titleMatches = titleWords.filter(word => chunkNorm.includes(word));\n    const titleMatchRate = titleMatches.length / titleWords.length;\n    \n    if (titleMatchRate < 0.5) {\n      console.log(`Poor title match ${(titleMatchRate * 100).toFixed(0)}% for: ${item.Title_Of_AI_Use_Case}`);\n      return false;\n    }\n  }\n  \n  // 2. Business context check - industry or function should match\n  const industry = norm(ensureString(item.Industry));\n  const subindustry = norm(ensureString(item.Subindustry));\n  const businessFunc = norm(ensureString(item.Business_Function));\n  \n  let hasBusinessContext = false;\n  \n  if (industry.length > 3) {\n    hasBusinessContext = chunkNorm.includes(industry);\n  }\n  if (!hasBusinessContext && subindustry.length > 3) {\n    hasBusinessContext = chunkNorm.includes(subindustry);\n  }\n  if (!hasBusinessContext && businessFunc.length > 5) {\n    const funcWords = businessFunc.split(/\\s+/).filter(w => w.length > 3);\n    hasBusinessContext = funcWords.some(word => chunkNorm.includes(word));\n  }\n  \n  if (!hasBusinessContext) {\n    console.log(`No business context found for: ${item.Title_Of_AI_Use_Case}`);\n    return false;\n  }\n  \n  // 3. Technology relevance check\n  const description = norm(ensureString(item.Description));\n  const aiTech = norm(ensureString(item.AI_Capabilities_And_Tech));\n  \n  // Look for any AI/tech indicators in source\n  const techIndicators = [\n    \"technology\", \"system\", \"software\", \"platform\", \"solution\", \"tool\", \"application\",\n    \"ai\", \"artificial intelligence\", \"machine learning\", \"algorithm\", \"model\", \"data\",\n    \"automat\", \"digital\", \"smart\", \"intelligent\", \"analytic\", \"process\", \"detect\",\n    \"predict\", \"recogni\", \"optim\", \"efficien\", \"improv\", \"enhanc\"\n  ];\n  \n  const hasTechContext = techIndicators.some(indicator => chunkNorm.includes(indicator));\n  \n  if (!hasTechContext) {\n    console.log(`No technology context found for: ${item.Title_Of_AI_Use_Case}`);\n    return false;\n  }\n  \n  return true;\n}\n\n// Check for obvious hallucination patterns\nfunction detectHallucination(item, chunk) {\n  const chunkNorm = norm(chunk);\n  const title = norm(ensureString(item.Title_Of_AI_Use_Case));\n  const desc = norm(ensureString(item.Description));\n  \n  // 1. Check for very specific claims that should have evidence\n  const specificClaims = [\n    { claim: \"fraud detection\", evidence: [\"fraud\", \"detect\", \"suspicious\", \"transaction\"] },\n    { claim: \"image recognition\", evidence: [\"image\", \"visual\", \"picture\", \"photo\", \"recogni\"] },\n    { claim: \"speech recognition\", evidence: [\"speech\", \"voice\", \"audio\", \"sound\", \"recogni\"] },\n    { claim: \"natural language\", evidence: [\"language\", \"text\", \"nlp\", \"linguistic\", \"word\"] },\n    { claim: \"predictive maintenance\", evidence: [\"maintenance\", \"equipment\", \"machine\", \"predict\"] },\n    { claim: \"customer service\", evidence: [\"customer\", \"service\", \"support\", \"client\"] },\n    { claim: \"inventory management\", evidence: [\"inventory\", \"stock\", \"warehouse\", \"supply\"] },\n    { claim: \"quality control\", evidence: [\"quality\", \"defect\", \"inspect\", \"standard\"] }\n  ];\n  \n  for (const specific of specificClaims) {\n    if (title.includes(specific.claim) || desc.includes(specific.claim)) {\n      const hasEvidence = specific.evidence.some(evidence => chunkNorm.includes(evidence));\n      if (!hasEvidence) {\n        console.log(`Specific claim \"${specific.claim}\" lacks evidence in source: ${item.Title_Of_AI_Use_Case}`);\n        return true; // This is likely hallucinated\n      }\n    }\n  }\n  \n  // 2. Check for generic AI buzzwords without context\n  const genericPhrases = [\n    \"leverage ai\", \"ai-powered solution\", \"cutting-edge technology\",\n    \"revolutionary approach\", \"next-generation platform\", \"advanced analytics\"\n  ];\n  \n  const hasGenericBuzzwords = genericPhrases.some(phrase => \n    title.includes(phrase) || desc.includes(phrase)\n  );\n  \n  if (hasGenericBuzzwords) {\n    console.log(`Generic buzzwords detected: ${item.Title_Of_AI_Use_Case}`);\n    return true;\n  }\n  \n  return false;\n}\n\n// Validate numeric claims\nfunction validateNumbers(item, chunk) {\n  const impact = norm(ensureString(item.Impact));\n  const numbers = impact.match(/\\d+(?:\\.\\d+)?%?/g);\n  \n  if (!numbers || numbers.length === 0) return true; // No numbers to validate\n  \n  const chunkNorm = norm(chunk);\n  \n  // Check if any of the numbers appear in source\n  const hasAnyNumberEvidence = numbers.some(num => {\n    const cleanNum = num.replace('%', '');\n    return chunkNorm.includes(cleanNum) || chunkNorm.includes(num);\n  });\n  \n  if (!hasAnyNumberEvidence) {\n    console.log(`Numeric claims without evidence: ${item.Title_Of_AI_Use_Case}`);\n    // Soften the impact rather than reject entirely\n    item.Impact = impact.replace(/\\d+(?:\\.\\d+)?%?/g, \"significant\").replace(/\\s+/g, \" \").trim();\n  }\n  \n  return true; // Don't filter based on numbers alone\n}\n\n// Main grounding validation\n\nfunction validateToolsAndPlatforms(item, chunk) {\n    const tools = toStr(item.Digital_Platforms_And_Tools);\n    const chunkNorm = norm(chunk);\n    \n    if (tools && !tools.includes(\"http\")) { // Skip URLs\n        // Check if any tool/platform is actually mentioned in the source\n        const toolWords = tools.split(/[,;]/).map(t => norm(t.trim())).filter(t => t.length > 3);\n        const hasEvidence = toolWords.some(tool => chunkNorm.includes(tool));\n        \n        if (!hasEvidence && toolWords.length > 0) {\n            console.log(`🛠️  Removing ungrounded tools: ${tools}`);\n            item.Digital_Platforms_And_Tools = \"\"; // Clear unsubstantiated tools\n        }\n    }\n    return true;\n}\nfunction isGrounded(item, chunkText) {\n  const chunk = norm(chunkText);\n  \n  // Must pass basic grounding\n  if (!hasBasicGrounding(item, chunk)) {\n    return false;\n  }\n  \n  // Must not be obvious hallucination\n  if (detectHallucination(item, chunk)) {\n    return false;\n  }\n  \n  // Validate and fix numbers\n  validateNumbers(item, chunk);\n  validateToolsAndPlatforms(item, chunk);\n  \n  console.log(`✓ Passed grounding: ${item.Title_Of_AI_Use_Case}`);\n  return true;\n}\n\nconst out = [];\nlet totalFiltered = 0;\nlet totalProcessed = 0;\n\nfor (const it of $input.all()) {\n  totalProcessed++;\n  const o = it.json || {};\n  const chunkText = toStr(o._chunk_content ?? \"\");\n\n  if (!hasText(chunkText)) {\n    console.log(\"No chunk content, skipping\");\n    totalFiltered++;\n    continue;\n  }\n\n  if (!isGrounded(o, chunkText)) {\n    totalFiltered++;\n    continue;\n  }\n\n  const cleaned = { ...o };\n  delete cleaned._chunk_content;\n  out.push({ json: cleaned });\n}\n\nconst retentionRate = totalProcessed > 0 ? ((out.length / totalProcessed) * 100).toFixed(1) : \"0.0\";\n\nconsole.log(`Balanced Grounding Filter Results:`);\nconsole.log(`  Total processed: ${totalProcessed}`);\nconsole.log(`  Kept: ${out.length}`);\nconsole.log(`  Filtered: ${totalFiltered}`);\nconsole.log(`  Retention rate: ${retentionRate}%`);\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8976,
        624
      ],
      "id": "3241a3b1-2658-4266-9a17-102cb1f5ed17",
      "name": "Post Grounding Filter",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// LLM Output Validator & Fixer\n// Ensures the LLM output is properly formatted and breaks apart combined use cases\n\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\n\nfunction splitCombinedUseCases(llmOutput) {\n    // Check if the LLM combined multiple use cases into one object\n    const combinedIndicators = [\n        /(?:and|along with|as well as|additionally|also|,)\\s+ai\\s+/gi,\n        /multiple|various|several|many|a range of|a variety of/gi,\n        /both.*and|either.*or|not only.*but also/gi\n    ];\n    \n    // If the output is a single object (not array), wrap it in an array\n    let parsedOutput;\n    try {\n        parsedOutput = JSON.parse(llmOutput);\n    } catch (e) {\n        console.log(\"❌ Invalid JSON from LLM, returning empty array\");\n        return [];\n    }\n    \n    // Ensure we're working with an array\n    if (!Array.isArray(parsedOutput)) {\n        parsedOutput = [parsedOutput];\n    }\n    \n    const finalUseCases = [];\n    \n    for (const useCase of parsedOutput) {\n        const description = toStr(useCase.Description);\n        const title = toStr(useCase.Title_Of_AI_Use_Case);\n        \n        // Check if this looks like combined use cases\n        const isCombined = combinedIndicators.some(indicator => \n            indicator.test(description) || indicator.test(title)\n        );\n        \n        if (isCombined && description.length > 200) {\n            console.log(\"⚠️  Found potentially combined use case, attempting to split:\", title);\n            \n            // Try to split by common separators\n            const splitPatterns = [\n                /(\\d+[\\.\\)]\\s+|\\[a-z\\][\\.\\)]\\s+|•\\s+|-\\s+)/gi, // numbered lists, bullet points\n                /(?:and|along with|as well as|additionally)\\s+/gi,\n                /\\.\\s+(?=[A-Z][a-z])/g // sentence boundaries before capital letters\n            ];\n            \n            let splitFound = false;\n            for (const pattern of splitPatterns) {\n                if (pattern.test(description)) {\n                    // For now, just flag it - we'll rely on the better prompt to prevent combining\n                    console.log(\"   Found combinination pattern, but relying on improved prompt\");\n                    splitFound = true;\n                    break;\n                }\n            }\n            \n            if (!splitFound) {\n                console.log(\"   No clear split points found\");\n            }\n        }\n        \n        finalUseCases.push(useCase);\n    }\n    \n    return finalUseCases;\n}\n\n// Main execution\nconst outputItems = [];\n\nfor (const item of $input.all()) {\n    const llmOutput = toStr(item.json?.message);\n    const chunkIndex = item.json?.chunk_index || 0;\n    const documentId = item.json?.documentId || \"\";\n    \n    if (!llmOutput || llmOutput === \"[]\") {\n        // Pass through empty results\n        outputItems.push(item);\n        continue;\n    }\n    \n    try {\n        const validatedUseCases = splitCombinedUseCases(llmOutput);\n        \n        if (validatedUseCases.length === 0) {\n            outputItems.push({\n                json: {\n                    message: \"[]\",\n                    chunk_index: chunkIndex,\n                    documentId: documentId\n                }\n            });\n        } else {\n            outputItems.push({\n                json: {\n                    message: JSON.stringify(validatedUseCases),\n                    chunk_index: chunkIndex,\n                    documentId: documentId,\n                    content: item.json?.content // preserve original content for grounding\n                }\n            });\n        }\n        \n    } catch (error) {\n        console.log(\"❌ Error validating LLM output:\", error.message);\n        // Pass through empty result on error\n        outputItems.push({\n            json: {\n                message: \"[]\",\n                chunk_index: chunkIndex,\n                documentId: documentId\n            }\n        });\n    }\n}\n\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8768,
        224
      ],
      "id": "2469385d-139b-4b4e-b7fb-2e049a60ab93",
      "name": "LLM Output Validator"
    },
    {
      "parameters": {
        "jsCode": "// Use Case Integrity Check - Ensures complete extraction and prevents grouping\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\n\nfunction looksLikeCombinedUseCase(useCase) {\n    const title = toStr(useCase.Title_Of_AI_Use_Case);\n    const description = toStr(useCase.Description);\n    \n    // Check for multiple numbered items in title or description\n    const hasMultipleNumbers = (/\\d+\\.\\s+\\w+.+?\\d+\\.\\s+\\w+/gi.test(title) || /\\d+\\.\\s+\\w+.+?\\d+\\.\\s+\\w+/gi.test(description));\n    \n    // Check for conjunction words suggesting combination\n    const hasConjunctions = (/,\\s+(and|or|as well as|along with|plus)/gi.test(title) || /,\\s+(and|or|as well as|along with|plus)/gi.test(description));\n    \n    // Check for overly long titles suggesting multiple concepts\n    const isOverlyBroad = title.split(/\\s+/).length > 12;\n    \n    return hasMultipleNumbers || hasConjunctions || isOverlyBroad;\n}\n\nfunction splitCombinedUseCase(combinedUseCase, chunkContent) {\n    // This is a complex operation - for now, we'll just flag it for review\n    // In a production system, you might implement actual splitting logic here\n    console.log(`⚠️  POTENTIALLY COMBINED USE CASE: \"${combinedUseCase.Title_Of_AI_Use_Case}\"`);\n    \n    // For now, return the original but flag it\n    return [{\n        ...combinedUseCase,\n        _flagged: \"potentially_combined\"\n    }];\n}\n\nfunction ensureCompleteExtraction(useCases, chunkContent) {\n    const results = [];\n    \n    for (const useCase of useCases) {\n        // Check if this looks like multiple use cases combined into one\n        if (looksLikeCombinedUseCase(useCase)) {\n            const splitCases = splitCombinedUseCase(useCase, chunkContent);\n            results.push(...splitCases);\n        } else {\n            results.push(useCase);\n        }\n    }\n    \n    return results;\n}\n\n// Main processing\nconst outputItems = [];\nlet totalInput = 0;\nlet totalOutput = 0;\n\nfor (const item of $input.all()) {\n    const useCaseData = item.json;\n    const chunkContent = toStr(useCaseData._chunk_content || \"\");\n    \n    totalInput++;\n    \n    if (!useCaseData.Title_Of_AI_Use_Case) {\n        console.log(\"Skipping item without title\");\n        continue;\n    }\n    \n    // Check and ensure complete extraction\n    const validatedUseCases = ensureCompleteExtraction([useCaseData], chunkContent);\n    \n    for (const validUseCase of validatedUseCases) {\n        outputItems.push({\n            json: validUseCase\n        });\n        totalOutput++;\n    }\n}\n\nconsole.log(`✅ Integrity Check: ${totalInput} input -> ${totalOutput} output use cases`);\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9488,
        368
      ],
      "id": "a2d0f7e1-1a9b-4dac-9141-adc2b532b7d2",
      "name": "Use Case Integrity Check"
    },
    {
      "parameters": {
        "jsCode": "// Subindustry Enricher - Ensures consistent subindustry population\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\nconst hasValue = v => toStr(v).length > 2; // More than 2 characters\n\n// Industry to Subindustry mapping\nconst INDUSTRY_SUBINDUSTRY_MAP = {\n    'healthcare': ['Healthcare Technology', 'Medical Analytics', 'Clinical AI', 'Pharmaceutical Research'],\n    'finance': ['Financial Technology', 'Banking Analytics', 'Investment AI', 'Risk Management', 'Fintech'],\n    'retail': ['Retail Technology', 'E-commerce Analytics', 'Supply Chain AI', 'Customer Experience'],\n    'manufacturing': ['Industrial Technology', 'Smart Manufacturing', 'Supply Chain AI', 'Quality Analytics'],\n    'technology': ['Software Development', 'AI Platforms', 'Data Analytics', 'Cloud Computing'],\n    'transportation': ['Logistics Technology', 'Smart Mobility', 'Supply Chain AI', 'Fleet Management'],\n    'energy': ['Energy Technology', 'Smart Grid Analytics', 'Renewable Energy AI', 'Resource Management'],\n    'education': ['EdTech', 'Learning Analytics', 'Educational AI', 'Online Education'],\n    'default': ['Technology Solutions', 'Business Analytics', 'AI Applications']\n};\n\nfunction deriveSubindustry(industry, title, description) {\n    const industryKey = (industry || '').toLowerCase();\n    const fullText = (title + ' ' + description).toLowerCase();\n    \n    // First, try to extract from context\n    if (fullText.includes('supply chain')) return 'Supply Chain Technology';\n    if (fullText.includes('customer')) return 'Customer Experience';\n    if (fullText.includes('quality')) return 'Quality Analytics';\n    if (fullText.includes('logistics')) return 'Logistics Technology';\n    if (fullText.includes('clinical') || fullText.includes('medical')) return 'Clinical Technology';\n    if (fullText.includes('financial') || fullText.includes('banking')) return 'Financial Technology';\n    \n    // Then use industry mapping\n    for (const [key, subindustries] of Object.entries(INDUSTRY_SUBINDUSTRY_MAP)) {\n        if (industryKey.includes(key)) {\n            return subindustries[0]; // Return first relevant subindustry\n        }\n    }\n    \n    // Final fallback\n    return INDUSTRY_SUBINDUSTRY_MAP.default[0];\n}\n\nfunction enrichSubindustry(useCase) {\n    const enriched = { ...useCase };\n    \n    if (!hasValue(enriched.Subindustry) && hasValue(enriched.Industry)) {\n        enriched.Subindustry = deriveSubindustry(\n            enriched.Industry,\n            enriched.Title_Of_AI_Use_Case,\n            enriched.Description\n        );\n        console.log(`   ➕ Added Subindustry: ${enriched.Subindustry}`);\n        return enriched;\n    }\n    \n    return enriched; // No changes needed\n}\n\n// Main processing\nconst results = [];\nlet enrichedCount = 0;\nlet totalCount = 0;\n\nfor (const item of $input.all()) {\n    const useCase = item.json;\n    totalCount++;\n    \n    if (!useCase || !useCase.Title_Of_AI_Use_Case) {\n        results.push(item);\n        continue;\n    }\n    \n    const originalSubindustry = toStr(useCase.Subindustry);\n    const enrichedUseCase = enrichSubindustry(useCase);\n    \n    if (toStr(enrichedUseCase.Subindustry) !== originalSubindustry) {\n        enrichedCount++;\n    }\n    \n    results.push({ json: enrichedUseCase });\n}\n\nconsole.log(`Subindustry Enrichment: ${enrichedCount}/${totalCount} use cases enhanced`);\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9312,
        368
      ],
      "id": "b506e954-4378-48e6-833a-843b3442945b",
      "name": "Subindustry Enricher"
    },
    {
      "parameters": {
        "jsCode": "// Utility: extract trailing integer from an Id string, tolerant of prefixes (e.g., \"UC12\", \"uc-007\", \"15\")\nfunction extractTrailingNumber(idStr) {\n  if (!idStr && idStr !== 0) return null;\n  const s = String(idStr).trim();\n  // Match last run of digits in the string\n  const m = s.match(/(\\d+)\\s*$/);\n  if (!m) return null;\n  const n = parseInt(m[1], 10);\n  return Number.isNaN(n) ? null : n;\n}\n\n// 1) Gather all incoming items\nconst items = $input.all();\n\n// 2) Find the highest numeric suffix from any \"Id\" fields\nlet maxNum = 0;\nfor (const it of items) {\n  const idVal =\n    it.json?.Id ??\n    it.json?.id ?? // be tolerant of lowercase\n    null;\n\n  const num = extractTrailingNumber(idVal);\n  if (num !== null && num > maxNum) {\n    maxNum = num;\n  }\n}\n\n// 3) Extract a URL to carry forward (Merge1 should provide an item with URL)\nlet foundUrl = \"\";\nfor (const it of items) {\n  const urlCandidate =\n    it.json?.URL ??\n    it.json?.Url ??\n    it.json?.url ??\n    \"\";\n  if (urlCandidate && String(urlCandidate).trim()) {\n    foundUrl = String(urlCandidate).trim();\n    break; // take the first non-empty URL\n  }\n}\n\n// 4) Prepare a single control item that downstream nodes can read\nconst controlItem = {\n  json: {\n    highestIdNum: maxNum,\n    nextIdNum: maxNum + 1,\n    url: foundUrl\n  }\n};\n\n// 5) Option A: return original items plus the control item (default)\n//return [...items, controlItem];\n\n// 5) Option B: if you prefer returning only the control item, replace the line above with:\n return [controlItem];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7232,
        624
      ],
      "id": "9a74d6f1-8eb2-47ef-a7c7-04f512ee97d1",
      "name": "Get Id and URL"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "14bf176b-4bdc-460e-9936-64e71a8458cd",
              "name": "documentId",
              "value": "={{ $json.documentId }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        7616,
        352
      ],
      "id": "60533c1a-6232-43bb-987a-2d033154d248",
      "name": "Set Doc Id"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        7008,
        624
      ],
      "id": "081754d1-ee6f-441e-9a2a-0ae72e2a7112",
      "name": "Merge Reference URL"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        7648,
        608
      ],
      "id": "5eb95b53-db51-4546-9da4-4ee5c6bb30c7",
      "name": "Merge All Data"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        8464,
        592
      ],
      "id": "45be55c5-ee8a-4d42-bf58-efd6c6879588",
      "name": "Update URLs to scrape sheet"
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 157514600,
          "mode": "list",
          "cachedResultName": "Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=157514600"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Generated Output": "Yes",
            "Document ID": "={{ $json.documentId }}"
          },
          "matchingColumns": [
            "Document ID"
          ],
          "schema": [
            {
              "id": "URL",
              "displayName": "URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Title",
              "displayName": "Title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Document ID",
              "displayName": "Document ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Document URL",
              "displayName": "Document URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is Scraped",
              "displayName": "Is Scraped",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is deleted",
              "displayName": "Is deleted",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Generated Output",
              "displayName": "Generated Output",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        8656,
        592
      ],
      "id": "1f17a1d6-40f8-4d67-9e88-cbad4d441bc5",
      "name": "Update URLs to scrape sheet1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        8976,
        368
      ],
      "id": "2a1e1281-b45f-42f4-8a1e-49add6327e99",
      "name": "Merge Chunks with generated output"
    },
    {
      "parameters": {
        "jsCode": "// Flatten Chunk Output (final)\n// - Works with JSON array string or already-parsed array\n// - Emits one item per valid object\n// - Attaches _chunk_index, _documentId, _chunk_content (for Grounding Filter)\n// - Normalizes array/object fields to strings for consistency\n\nconst REQUIRED_KEYS = [\n  \"Industry\",\n  \"Subindustry\",\n  \"Business_Function\",\n  \"Business_Capability\",\n  \"Stakeholder_Or_User\",\n  \"Title_Of_AI_Use_Case\",\n  \"Description\",\n  \"Impact\",\n  \"Action_Implementation_Plan\",\n  \"Expected_Outcomes_And_Results\",\n  \"Datasets\",\n  \"AI_Capabilities_And_Tech\",\n  \"Digital_Platforms_And_Tools\",\n  \"AI_Algo_And_Frameworks\",\n  \"Tools_And_Models\",\n  \"Other_References\"\n];\n\n// Fields to coerce into strings (prevents downstream phrase/dedupe issues)\nconst FORCE_STRING_FIELDS = [\n  \"Industry\",\n  \"Subindustry\",\n  \"Business_Function\",\n  \"Business_Capability\",\n  \"Stakeholder_Or_User\",\n  \"Title_Of_AI_Use_Case\",\n  \"Description\",\n  \"Impact\",\n  \"Action_Implementation_Plan\",\n  \"Expected_Outcomes_And_Results\",\n  \"Datasets\",\n  \"AI_Capabilities_And_Tech\",\n  \"Digital_Platforms_And_Tools\",\n  \"AI_Algo_And_Frameworks\",\n  \"Tools_And_Models\",\n  \"Other_References\"\n];\n\nconst toStr = v => (v == null ? \"\" : String(v));\nconst isObj = v => v && typeof v === \"object\" && !Array.isArray(v);\n\nfunction extractFirstJsonArray(raw) {\n  const s = toStr(raw).trim();\n  if (!s) return null;\n\n  // Try direct parse\n  try {\n    const p = JSON.parse(s);\n    if (Array.isArray(p)) return p;\n  } catch {}\n\n  // Fallback: slice first [ ... ] block\n  const first = s.indexOf(\"[\");\n  const last  = s.lastIndexOf(\"]\");\n  if (first === -1 || last === -1 || last <= first) return null;\n\n  try {\n    const p2 = JSON.parse(s.slice(first, last + 1));\n    return Array.isArray(p2) ? p2 : null;\n  } catch {}\n\n  return null;\n}\n\nfunction hasAllRequiredKeys(o) {\n  if (!isObj(o)) return false;\n  return REQUIRED_KEYS.every(k => Object.prototype.hasOwnProperty.call(o, k));\n}\n\nfunction forceStrings(o) {\n  const out = { ...o };\n  for (const k of FORCE_STRING_FIELDS) {\n    const v = out[k];\n    if (Array.isArray(v)) {\n      out[k] = v.map(x => toStr(x).trim()).filter(Boolean).join(\"; \");\n    } else if (v && typeof v === \"object\") {\n      out[k] = toStr(v);\n    } else {\n      out[k] = toStr(v);\n    }\n  }\n  return out;\n}\n\nconst results = [];\n\nfor (const item of $input.all()) {\n  // Get the original chunk data from the input\n  const chunkIndex = item.json?.chunk_index ?? null;\n  const documentId = item.json?.documentId ?? null;\n  \n  // IMPORTANT: Get the chunk content that was sent to the LLM\n  // It should be in the original request data\n  const chunkContent = item.json?.content ?? \"\";\n\n  // LLM output is in the message field from Perplexity\n  const raw = toStr(item.json?.message ?? \"\").trim();\n  const arr = extractFirstJsonArray(raw);\n\n  if (!arr) {\n    console.log(\"No valid JSON array found in:\", raw.substring(0, 200));\n    continue;\n  }\n\n  for (const obj of arr) {\n    if (!hasAllRequiredKeys(obj)) {\n      console.log(\"Missing required keys in object:\", Object.keys(obj));\n      continue;\n    }\n\n    const normalized = forceStrings(obj);\n\n    results.push({\n      json: {\n        ...normalized,\n        _chunk_index: chunkIndex,\n        _documentId: documentId,\n        _chunk_content: toStr(chunkContent)\n      }\n    });\n  }\n}\n\nconsole.log(`Processed ${results.length} valid items`);\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9136,
        368
      ],
      "id": "143b9e28-14a9-40b5-8635-f7079add024a",
      "name": "Flatten Output"
    },
    {
      "parameters": {
        "model": "sonar",
        "messages": {
          "message": [
            {
              "content": "=ROLE: You are a PRECISE JSON extraction engine. Extract AI use cases EXACTLY as they appear. NO grouping, NO invention.\n\nCRITICAL RULES:\n1.  **ONE USE CASE PER ITEM:** NEVER combine multiple distinct use cases into one JSON object. If the text lists \"1. X, 2. Y, 3. Z\", create THREE separate objects.\n2.  **COMPLETE LISTS:** Extract EVERY item from numbered (1., 2., 3.), lettered (A., B., C.), bulleted (•, -), or any other list format.\n3.  **NO TRUNCATION:** Ensure the LAST items in lists are extracted completely. Pay extra attention to items at the end of sections.\n4.  **LITERAL EXTRACTION:** Extract use cases exactly as described. Do not infer, generalize, or combine related concepts.\n5.  **SOURCE BOUND:** Only extract what is explicitly described. Ignore introductory phrases like \"The applications are:\" or \"Uses include:\" - extract the actual listed items that follow.\n\nLIST HANDLING PROTOCOL:\n- **Numbered Lists:** \"1. Fraud Detection → 2. Chatbots\" = 2 SEPARATE use cases\n- **Lettered Lists:** \"A. Predictive Maintenance → B. Quality Control\" = 2 SEPARATE use cases  \n- **Bulleted Lists:** \"• Computer Vision → • NLP\" = 2 SEPARATE use cases\n- **Nested Lists:** Extract main items, use description for sub-items\n- **Incomplete Lists:** If description is cut off, use available text but flag if needed\n\nEXTRACTION FORMAT - CREATE ONE OBJECT PER DISTINCT USE CASE:\n{\n  \"Industry\": \"\",\t\t\t\t// Extract from context or use \"Multiple\"\n  \"Subindustry\": \"\",\t\t\t// Extract from context\n  \"Business_Function\": \"\",\t\t// e.g., \"Procurement\", \"Supply Chain\"\n  \"Business_Capability\": \"\",\t// e.g., \"Spend Analysis\", \"Demand Forecasting\"  \n  \"Stakeholder_Or_User\": \"\",\t// e.g., \"Procurement Managers\", \"Supply Chain Analysts\"\n  \"Title_Of_AI_Use_Case\": \"\",\t// MUST be specific: \"AI-Powered Spend Analysis and Categorization\"\n  \"Description\": \"\",\t\t\t// 2-3 sentences from the text\n  \"Impact\": \"\",\t\t\t\t\t// Extract or use \"Improves efficiency and accuracy\"\n  \"Action_Implementation_Plan\": \"1. Data Collection; 2. Model Training; 3. Deployment; 4. Monitoring\",\n  \"Expected_Outcomes_And_Results\": \"\", // Extract or use \"Increased operational efficiency\"\n  \"Datasets\": \"Historical transaction data, user behavior data\",\n  \"AI_Capabilities_And_Tech\": \"\", // MUST be specific: \"Machine Learning algorithms, NLP\"\n  \"Digital_Platforms_And_Tools\": \"\", // Extract platforms like \"AWS, Azure, Google Cloud\" or tools like \"TensorFlow, PyTorch\"\n  \"AI_Algo_And_Frameworks\": \"\",\t// e.g., \"Classification algorithms, Neural Networks, Random Forest\"\n  \"Tools_And_Models\": \"\",\t\t// e.g., \"TensorFlow, Predictive analytics platform, Custom ML models\"\n  \"Other_References\": \"\"\t\t// Use source URL if no specific reference\n}\n\nTECHNICAL FIELD EXTRACTION RULES:\n- **Digital_Platforms_And_Tools:** Extract cloud platforms (AWS, Azure, GCP), development tools, software platforms mentioned\n- **AI_Algo_And_Frameworks:** Extract specific algorithms (CNN, RNN, Random Forest), frameworks (Scikit-learn, TensorFlow)\n- **Tools_And_Models:** Extract specific tools (Python, R, Tableau) and model types (GPT-3, BERT, Custom models)\n- **CONTEXT-BASED POPULATION:** If technical details aren't explicitly stated but can be reasonably inferred from the use case description, populate these fields based on common industry practices\n\nFORMAT HANDLING:\n- **EXTRACT \"OPPORTUNITY:\" AS USE CASES:** When you see \"Opportunity: [description]\" or \"Solution: [description]\", treat these as use cases and extract them.\n- **COMPLETE EXTRACTION:** Ensure you capture ALL use cases in the chunk, especially those near the end. Do not stop early.\n- **HANDLE INCOMPLETE SENTENCES:** If a use case description is cut off at the chunk boundary, still extract it and note it may be incomplete.\n\nFIELD COMPLETENESS RULES:\n- **Subindustry MUST be populated:** If not specified, derive it from Industry + context (e.g., \"Healthcare Technology\", \"Financial Analytics\")\n- **ALL fields required:** Every use case object must have values for all 16 fields. Use context to derive missing information.\n- **Technical fields MUST be populated:** Use context clues to infer platforms, tools, and algorithms when not explicitly stated\n- **Consistent formatting:** Use title case for Industry/Business_Function, sentence case for Description/Impact\n- **References:** Use the source document URL for ALL use cases from this chunk\n- **Title:** Must be 5-15 words, descriptive and specific\n- **Description:** Must contain BOTH the business problem and the AI solution\n\nCHUNK AWARENESS PROTOCOL:\n- **THIS IS CHUNK {{ $json.chunk_index + 1 }} OF {{ $json.total_chunks }} :** You are processing part of a larger document.\n- **WATCH FOR TRUNCATION:** If a use case description seems incomplete or cut off, it may continue in the next chunk. Extract what's available.\n- **CONTINUED LISTS:** If you see \"5. Partial Use Case\" without completion, this might be continued. Extract it with a note.\n- **CROSS-CHUNK CONSISTENCY:** Maintain consistent field population across chunks from the same document.\n\nTRUNCATION HANDLING:\n- If a use case seems incomplete: Still extract it, but keep description concise\n- If numbered list is interrupted: Extract available items, assume continuation\n- If context is missing: Use available text, don't over-infer\n\nOUTPUT: \n- MUST be a single valid JSON array of objects\n- NO additional text, markdown, or explanations\n- If no valid use cases, return: []",
              "role": "system"
            },
            {
              "content": "=This is one chunk of a larger document. Apply the System Prompt rules strictly.\n\nInput chunk:\n{{ $json.filtered_content }}\n\nCRITICAL TASKS:\n1. Identify and extract every fundamentally distinct AI use case in this chunk\n2. Handle all structures: headings, numbered lists, bullet lists, A/B/C sub-items, nested structures\n3. **EXTRACT TECHNICAL DETAILS:** Pay special attention to platforms, tools, algorithms, and frameworks mentioned\n4. **INFER TECHNICAL CONTEXT:** When technical details aren't explicit but can be reasonably inferred from the use case description, populate Digital_Platforms_And_Tools, AI_Algo_And_Frameworks, and Tools_And_Models based on common industry practices\n5. Only include use cases with sufficient description of capability and application\n6. Do NOT create use cases from reference lists or citations; instead, attach references to the related use case in Other_References\n7. Output only a single valid JSON array; if none exist, return []\n\nTECHNICAL EXTRACTION GUIDELINES:\n- Look for: cloud platforms (AWS/Azure/GCP), tools (TensorFlow/PyTorch), algorithms (ML/NLP/CV), frameworks\n- If imaging/vision mentioned → include \"Computer Vision\" in AI_Capabilities\n- If text/language mentioned → include \"NLP\" in AI_Capabilities  \n- If prediction/forecasting → include \"Predictive Analytics\" in AI_Capabilities\n- If no specific tools mentioned → use \"Machine Learning Platform\" or \"AI Development Tools\""
            }
          ]
        },
        "simplify": true,
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexity",
      "typeVersion": 1,
      "position": [
        8400,
        224
      ],
      "id": "8c475807-c938-47fb-b818-cf28df80b6a0",
      "name": "LLM"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        7200,
        336
      ],
      "id": "6ec9286d-aae4-4da9-9e37-e4b7aba4a237",
      "name": "Loop Over Items1"
    },
    {
      "parameters": {
        "content": "Lead Recommendation_v1",
        "height": 464,
        "width": 2224
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        240,
        2880
      ],
      "id": "2971221a-e340-44a7-8458-f4d72de46d74",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw",
          "mode": "list",
          "cachedResultName": "Lead Recommendation Sample data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sales Record",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit#gid=0"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        544,
        2992
      ],
      "id": "22add1b7-e913-4030-bdb3-174062e30149",
      "name": "Get row(s) in sheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw",
          "mode": "list",
          "cachedResultName": "Lead Recommendation Sample data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1305946999,
          "mode": "list",
          "cachedResultName": "Recommendation list",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit#gid=1305946999"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        544,
        3136
      ],
      "id": "1d80affc-6d24-4287-add2-535eb433ef63",
      "name": "Get row(s) in sheet1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        768,
        3056
      ],
      "id": "64c8abbd-e4de-49e7-b4f3-ba47ab5b0412",
      "name": "Merge1"
    },
    {
      "parameters": {
        "model": "sonar",
        "messages": {
          "message": [
            {
              "content": "=You are a sales enablement and storage domain assistant specialized in Pure Storage offerings. Recommend complementary Pure Storage products strictly from the approved list provided for the given service, then compose a concise, conversion-focused cold email. Return strictly valid JSON in the exact schema requested. Do not include markdown, commentary, citations, or extra keys.",
              "role": "system"
            },
            {
              "content": "=Context:\n\nis_from_list: {{$json.is_from_list}}\n\nClient Id: {{$json[\"Client Id\"]}}\n\nClient Name: {{$json[\"Client Name\"]}}\n\nClient Email: {{$json[\"Client Email address\"]}}\n\nService Sold: {{$json[\"Service Sold\"]}}\n\nApproved recommendation list for this service:\n{{ $json._recommendedMap[$json[\"Service Sold\"]] }}\n\nTask:\n\nPropose 3–6 “New Service Recommendations” using only items from the approved list above; output as a plain array of strings.\n\nWrite a personalized, professional cold email about these recommendations. Keep it 120–170 words, include a subject line, greet by name, highlight clear value, add a concrete next step, and a friendly sign-off.\n\nOutput JSON ONLY in this exact shape:\n{\n\"recommendations\": [\"...\",\"...\"],\n\"email_subject\": \"...\",\n\"email_body\": \"...\"\n}\n\nNotes:\n\nIf the approved list is empty or missing, still return valid JSON by selecting 3–6 relevant Pure Storage offerings aligned to the stated service (e.g., FlashArray, FlashBlade, Pure1, Portworx, Cloud Block Store, Evergreen//One)."
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexity",
      "typeVersion": 1,
      "position": [
        1600,
        3120
      ],
      "id": "d7206328-912d-4604-8b4c-7aafec5fe40a",
      "name": "Message a model",
      "credentials": {
        "perplexityApi": {
          "id": "2X923WJEbWR6QPD5",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw",
          "mode": "list",
          "cachedResultName": "Lead Recommendation Sample data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sales Record",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Client Id": "={{ $json[\"Client Id\"] }}",
            "Recommended from list": "={{ $json[\"Recommended from list\"] }}",
            "Forwarded to LLM": "={{ $json[\"Forwarded to LLM\"] }}",
            "Message to be send as cold email generated by LLM": "={{ $json[\"Message to be send as cold email generated by LLM\"] }}",
            "Timestamp": "={{ $json.Timestamp }}",
            "Product Recommended": "={{ $json[\"Product Recommended\"] }}"
          },
          "matchingColumns": [
            "Client Id"
          ],
          "schema": [
            {
              "id": "Client Id",
              "displayName": "Client Id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Client Name",
              "displayName": "Client Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Client Email address",
              "displayName": "Client Email address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Service Sold",
              "displayName": "Service Sold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Product Recommended",
              "displayName": "Product Recommended",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Recommended from list",
              "displayName": "Recommended from list",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Forwarded to LLM",
              "displayName": "Forwarded to LLM",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Message to be send as cold email generated by LLM",
              "displayName": "Message to be send as cold email generated by LLM",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Timestamp",
              "displayName": "Timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2192,
        3120
      ],
      "id": "df19d963-ded4-4888-b646-d4666281e3f0",
      "name": "Append or update row in sheet1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Perplexity output, keep client fields, and stamp IST timestamps\n\n// --- Time helpers (IST = UTC+05:30) ---\nfunction toISOStringWithTz(date, tzMinutesOffset) {\n  const pad = n => String(Math.floor(Math.abs(n))).padStart(2, '0');\n  const local = new Date(date.getTime() + tzMinutesOffset * 60 * 1000);\n\n  const year = local.getUTCFullYear();\n  const month = pad(local.getUTCMonth() + 1);\n  const day = pad(local.getUTCDate());\n  const hours = pad(local.getUTCHours());\n  const minutes = pad(local.getUTCMinutes());\n  const seconds = pad(local.getUTCSeconds());\n\n  const sign = tzMinutesOffset >= 0 ? '+' : '-';\n  const hh = pad(tzMinutesOffset / 60);\n  const mm = pad(tzMinutesOffset % 60);\n\n  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${sign}${hh}:${mm}`;\n}\n\nfunction formatReadableIST(isoWithOffset) {\n  const [datePart, timeAndOffset] = isoWithOffset.split('T');\n  const time = timeAndOffset.slice(0, 8);   // HH:MM:SS\n  const offset = timeAndOffset.slice(8);    // +05:30\n  return `${datePart} ${time} IST (${offset})`;\n}\n\nconst IST_OFFSET_MIN = 330;\nconst isoIst = toISOStringWithTz(new Date(), IST_OFFSET_MIN);\nconst readableIst = formatReadableIST(isoIst);\n\n// --- Safe JSON parsing for LLM content ---\nfunction safeParseJson(s) {\n  if (typeof s === 'object' && s !== null) return s;\n  if (typeof s !== 'string') return null;\n  try { return JSON.parse(s); } catch { return null; }\n}\n\nconst out = [];\n\nfor (const item of $input.all()) {\n  const j = item.json || {};\n\n  // Try typical Perplexity response shapes\n  let content = j.content || j.message || j.data || j.result || j.text;\n  if (content && typeof content === 'object' && content.content) content = content.content;\n  if (Array.isArray(j.choices) && j.choices[0]?.message?.content) content = j.choices[0].message.content;\n\n  // Parse payload\n  let payload = null;\n  if (typeof content === 'object' && content !== null) payload = content;\n  if (!payload) payload = safeParseJson(content);\n  if (!payload && typeof j === 'string') payload = safeParseJson(j);\n\n  // Fallbacks\n  const recs = Array.isArray(payload?.recommendations) ? payload.recommendations : [];\n  const subj = payload?.email_subject || 'Exploring ways to expand your Pure Storage value';\n  const body = payload?.email_body || `Hi ${j['Client Name'] || 'there'},\\n\\nWe’d love to share a few complementary Pure Storage services that can expand performance, resilience, and efficiency. If interested, reply to schedule a quick call.\\n\\nBest regards,\\nTeam`;\n  // NEW: capitalize each recommendation's first letter\nfunction capitalizeFirstLetter(s) {\n  if (!s) return s;\n  const str = String(s).trim();\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst recsCapitalized = recs.map(capitalizeFirstLetter);\n\n\n  // Preserve client details; accept either Service Sold or Pure Storage Services Used field\n  const serviceSold = j['Service Sold'] ?? j['Pure Storage Services Used'] ?? '';\n\n  out.push({\n    json: {\n      'row_number': j['row_number'] ?? j['Row Number'] ?? '',\n      'Client Id': j['Client Id'],\n      'Client Name': j['Client Name'],\n      'Client Email address': j['Client Email address'],\n      'Service Sold': serviceSold,\n      'Product Recommended': recsCapitalized.join(', '),\n      'Recommended from list': 'No',\n      'Forwarded to LLM': 'Yes',\n      'Message to be send as cold email generated by LLM': `Subject: ${subj}\\n\\n${body}`,\n      // Human-friendly and machine-friendly timestamps in IST\n      'Timestamp': readableIst,\n      //'Timestamp (ISO+Offset)': isoIst\n    }\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        3120
      ],
      "id": "c655b56a-12ba-45b8-84f6-895c8b0fe9b5",
      "name": "Code in JavaScript3"
    },
    {
      "parameters": {
        "jsCode": "// BuildMap (case-insensitive)\n// Separates sales vs mapping, builds a recommendedMap where values are lowercased.\n// Downstream should also lowercase proposed items before comparison.\n\nconst incoming = $input.all();\n\nfunction toList(value) {\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') return value.split(',').map(s => s.trim()).filter(Boolean);\n  if (value == null) return [];\n  return [String(value).trim()].filter(Boolean);\n}\n\nconst sales = [];\nconst mapping = [];\nfor (const it of incoming) {\n  const j = it.json || {};\n  const hasSalesKeys = ('Client Id' in j) || ('Client Name' in j) || ('Client Email address' in j) || ('Pure Storage Services Used' in j);\n  const hasMapKeys = ('Pure Storage Service' in j) || ('Associated Products' in j);\n  if (hasMapKeys && !hasSalesKeys) mapping.push(j);\n  else if (hasSalesKeys) sales.push(j);\n}\n\nconst recommendedMap = {};\nfor (const row of mapping) {\n  const svc = String(row['Pure Storage Service'] || '').trim();\n  if (!svc) continue;\n  const assoc = toList(row['Associated Products']).map(s => s.toLowerCase());\n  if (!recommendedMap[svc]) recommendedMap[svc] = new Set();\n  for (const a of assoc) recommendedMap[svc].add(a);\n}\nconst recommendedMapArr = {};\nfor (const k of Object.keys(recommendedMap)) {\n  recommendedMapArr[k] = Array.from(recommendedMap[k]);\n}\n\nreturn sales.map(row => ({ json: { ...row, _recommendedMap: recommendedMapArr } }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        3056
      ],
      "id": "96eb89be-9bee-451a-83a7-cbfc6836c3ce",
      "name": "BuildMap"
    },
    {
      "parameters": {
        "jsCode": "// MatchPerRow (case-insensitive, robust)\n\n// Helpers\nfunction toList(value) {\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') return value.split(',').map(s => s.trim()).filter(Boolean);\n  if (value == null) return [];\n  return [String(value).trim()].filter(Boolean);\n}\n\nfunction dedupeKeepCase(arr) {\n  const seen = new Set();\n  const out = [];\n  for (const v of arr) {\n    const low = String(v).toLowerCase();\n    if (!seen.has(low)) {\n      seen.add(low);\n      out.push(String(v).trim());\n    }\n  }\n  return out.filter(Boolean);\n}\n\nconst results = [];\n\nfor (const item of $input.all()) {\n  const row = item.json || {};\n\n  // Accept either field naming convention\n  const svc = String(row['Pure Storage Services Used'] ?? row['Service Sold'] ?? '').trim();\n\n  // Accept either field for proposed list\n  const proposedRaw = row['New Service Recommendations'] ?? row['Product Recommended'] ?? '';\n  const proposed = toList(proposedRaw);\n  const proposedClean = dedupeKeepCase(proposed);\n\n  // Map of allowed recs by service should be attached by the previous node\n  const recMap = row._recommendedMap || {};\n  // The BuildMap variant A stores lowercase values; still normalize to be safe\n  const allowedLower = (recMap[svc] || []).map(s => String(s).toLowerCase());\n  const allowedSet = new Set(allowedLower);\n\n  const matched = [];\n  const missing = [];\n\n  for (const p of proposedClean) {\n    const low = p.toLowerCase();\n    if (allowedSet.has(low)) matched.push(p);\n    else missing.push(p);\n  }\n\n  // Business rule: mark true when there is at least one proposed and none are outside the list\n  const is_from_list = proposedClean.length > 0 && missing.length === 0;\n\n  results.push({\n    json: {\n      ...row,\n      matched,\n      missing,\n      is_from_list,\n      normalized_recommendations: proposedClean.join(', ')\n    }\n  });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1104,
        3056
      ],
      "id": "d302f41e-d023-453e-9725-93abef861847",
      "name": "MatchPerRow"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "412c2b66-7ebd-4a48-b184-47c9f545d321",
              "name": "Client Id",
              "value": "={{ $('If1').item.json[\"Client Id\"] }}",
              "type": "number"
            },
            {
              "id": "78cefd84-aa6a-49bf-8d91-977ad9a2e263",
              "name": "Client Name",
              "value": "={{ $('If1').item.json[\"Client Name\"] }}",
              "type": "string"
            },
            {
              "id": "d5306fce-188b-441c-9904-142e56e7e6d6",
              "name": "Service Sold",
              "value": "={{ $('If1').item.json[\"Service Sold\"] }}",
              "type": "string"
            },
            {
              "id": "58f940df-7742-4d12-8bba-cfaa3befc254",
              "name": "choices[0].message.content",
              "value": "={{ $json.choices[0].message.content }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1808,
        3120
      ],
      "id": "e7fd0ca1-5293-4195-8c7f-8ab21ad0f6f8",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw",
          "mode": "list",
          "cachedResultName": "Lead Recommendation Sample data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sales Record",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Client Id": "={{ $json[\"Client Id\"] }}",
            "Recommended from list": "={{ $json[\"Recommended from list\"] }}",
            "Forwarded to LLM": "={{ $json[\"Forwarded to LLM\"] }}",
            "Timestamp": "={{ $json.Timestamp }}"
          },
          "matchingColumns": [
            "Client Id"
          ],
          "schema": [
            {
              "id": "Client Id",
              "displayName": "Client Id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Client Name",
              "displayName": "Client Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Client Email address",
              "displayName": "Client Email address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Service Sold",
              "displayName": "Service Sold",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Product Recommended",
              "displayName": "Product Recommended",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Recommended from list",
              "displayName": "Recommended from list",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Forwarded to LLM",
              "displayName": "Forwarded to LLM",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Message to be send as cold email generated by LLM",
              "displayName": "Message to be send as cold email generated by LLM",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Timestamp",
              "displayName": "Timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        1856,
        2960
      ],
      "id": "24f81753-2a97-4209-b43c-702328a2ace3",
      "name": "Append or update row in sheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build a human-friendly IST timestamp and also an ISO-with-offset string\nfunction toISOStringWithTz(date, tzMinutesOffset) {\n  const pad = n => String(Math.floor(Math.abs(n))).padStart(2, '0');\n  const local = new Date(date.getTime() + tzMinutesOffset * 60 * 1000);\n\n  const year = local.getUTCFullYear();\n  const month = pad(local.getUTCMonth() + 1);\n  const day = pad(local.getUTCDate());\n  const hours = pad(local.getUTCHours());\n  const minutes = pad(local.getUTCMinutes());\n  const seconds = pad(local.getUTCSeconds());\n\n  const sign = tzMinutesOffset >= 0 ? '+' : '-';\n  const hh = pad(tzMinutesOffset / 60);\n  const mm = pad(tzMinutesOffset % 60);\n\n  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${sign}${hh}:${mm}`;\n}\n\nfunction formatReadableIST(isoWithOffset) {\n  // Convert \"YYYY-MM-DDTHH:MM:SS+05:30\" -> \"YYYY-MM-DD HH:MM:SS IST (+05:30)\"\n  const [datePart, timeAndOffset] = isoWithOffset.split('T');\n  const time = timeAndOffset.slice(0, 8); // HH:MM:SS\n  const offset = timeAndOffset.slice(8);  // +05:30\n  return `${datePart} ${time} IST (${offset})`;\n}\n\nconst IST_OFFSET_MIN = 330; // UTC+05:30\nconst isoIst = toISOStringWithTz(new Date(), IST_OFFSET_MIN);\nconst readableIst = formatReadableIST(isoIst);\n\nconst output = [];\nfor (const item of $input.all()) {\n  const j = item.json;\n\n  const finalRecs = (j.normalized_recommendations && j.normalized_recommendations.length)\n    ? j.normalized_recommendations\n    : (Array.isArray(j.matched) ? j.matched.join(', ') : (j['New Service Recommendations'] || j['Product Recommended'] || ''));\n\n  output.push({\n    json: {\n      'Client Id': j['Client Id'],\n      'Client Name': j['Client Name'],\n      'Client Email address': j['Client Email address'],\n      'Service Sold': j['Pure Storage Services Used'] ?? j['Service Sold'],\n      'Product Recommended': finalRecs,\n      'Recommended from list': 'Yes',\n      'Forwarded to LLM': 'No',\n      'Message to be send as cold email generated by LLM': j['Message to be send as cold email generated by LLM'] || '',\n      // Renamed field to \"Timestamp\" with readable format\n      'Timestamp': readableIst,\n      // Optional: also store raw ISO with offset for systems\n      //'Timestamp (ISO+Offset)': isoIst\n    }\n  });\n}\n\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        2960
      ],
      "id": "53a4f125-a16b-4eca-9b25-dcb52debd6b5",
      "name": "Format Output"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "b1ab214a-430b-4512-84d5-c005f072b973",
              "leftValue": "={{ $json.is_from_list }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1280,
        3056
      ],
      "id": "2f7834ac-b9e9-4fa0-bf18-a05e6cc1311a",
      "name": "If1"
    },
    {
      "parameters": {
        "content": "Lead Recommendation_v2",
        "height": 432,
        "width": 1856
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        512,
        3664
      ],
      "id": "6a1bfd3e-b572-409f-bd79-5951c032ddf6",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw",
          "mode": "list",
          "cachedResultName": "Lead Recommendation Sample data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 15024551,
          "mode": "list",
          "cachedResultName": "Sales Record_v2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit#gid=15024551"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        752,
        3744
      ],
      "id": "c2f218c0-6366-4b58-ba0f-136194ad5145",
      "name": "Get row(s) in sheet2",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw",
          "mode": "list",
          "cachedResultName": "Lead Recommendation Sample data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1715613241,
          "mode": "list",
          "cachedResultName": "Recommendation list_v2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit#gid=1715613241"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        752,
        3888
      ],
      "id": "021b95b7-9205-4313-8119-de1739a16f35",
      "name": "Get row(s) in sheet3",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        976,
        3824
      ],
      "id": "4e4d5fe5-5a36-4b42-89d7-8918dc2b4c07",
      "name": "Merge2"
    },
    {
      "parameters": {
        "model": "sonar",
        "messages": {
          "message": [
            {
              "content": "=You are a sales enablement and storage domain assistant specialized in Pure Storage offerings. Recommend complementary Pure Storage products strictly from the approved list provided for the client’s inquired service, then compose a concise, conversion-focused cold email. Return strictly valid JSON in the exact schema requested. Do not include markdown, commentary, citations, or extra keys.",
              "role": "system"
            },
            {
              "content": "=Context:\n\nClient Id: {{$json[\"Client Id\"]}}\n\nClient Name: {{$json[\"Client Name\"]}}\n\nClient Email: {{$json[\"Client Email address\"]}}\n\nProduct Inquiry: {{$json[\"Product Inquiry\"]}}\n\nApproved recommendation list for this service:\n{{ $json._approvedForInquiry }}\n\nTask:\n\nPropose 4–6 “Product Recommended” using only items from the approved list above; output as a plain array of strings.\n\nWrite a personalized, professional cold email about these recommendations. Keep it 120–170 words, include a subject line, greet by name, highlight clear value, add a concrete next step, and a friendly sign-off.\n\nOutput JSON ONLY in this exact shape:\n{\n\"recommendations\": [\"...\",\"...\"],\n\"email_subject\": \"...\",\n\"email_body\": \"...\"\n}\n\nNotes:\n\nIf the approved list is empty or missing, still return valid JSON by selecting 4–6 widely adopted Pure Storage offerings aligned to the inquiry (e.g., FlashArray, FlashBlade, Pure1, Portworx, Cloud Block Store, Evergreen//One).\n\nTip: If available in the Perplexity node, set response_format to a JSON schema enforcing:\n{\ntype: \"object\",\nproperties: {\nrecommendations: { type: \"array\", items: { type: \"string\" }, minItems: 4, maxItems: 6 },\nemail_subject: { type: \"string\" },\nemail_body: { type: \"string\" }\n},\nrequired: [\"recommendations\",\"email_subject\",\"email_body\"],\nadditionalProperties: false\n}\nto increase compliance."
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexity",
      "typeVersion": 1,
      "position": [
        1728,
        3888
      ],
      "id": "55875257-a511-43a3-8425-7ae0b0b94026",
      "name": "Message a model1",
      "credentials": {
        "perplexityApi": {
          "id": "2X923WJEbWR6QPD5",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw",
          "mode": "list",
          "cachedResultName": "Lead Recommendation Sample data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 15024551,
          "mode": "list",
          "cachedResultName": "Sales Record_v2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit#gid=15024551"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Client Id": "={{ $json[\"Client Id\"] }}",
            "Forwarded to LLM": "={{ $json[\"Forwarded to LLM\"] }}",
            "Timestamp": "={{ $json.Timestamp }}",
            "Product Recommended": "={{ $json[\"Product Recommended\"] }}",
            "Email Message": "={{ $json[\"Email Message\"] }}"
          },
          "matchingColumns": [
            "Client Id"
          ],
          "schema": [
            {
              "id": "Client Id",
              "displayName": "Client Id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Client Name",
              "displayName": "Client Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Client Email address",
              "displayName": "Client Email address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Product Inquiry",
              "displayName": "Product Inquiry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Product Recommended",
              "displayName": "Product Recommended",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Email Message",
              "displayName": "Email Message",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Forwarded to LLM",
              "displayName": "Forwarded to LLM",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Timestamp",
              "displayName": "Timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        1760,
        3712
      ],
      "id": "614d3b90-7e56-4c8a-81aa-25d670903cae",
      "name": "Append or update row in sheet2",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// BuildMap + Prepare Inquiry Items (case-insensitive)\n// Input: Mixed items from Sales Record (with \"Product Inquiry\") and Recommendation list\n// Output: One item per sales row with:\n//   - _recommendedMap: { serviceName -> [lowercase associated products] }\n//   - _approvedForInquiry: [lowercase associated products for the row's Product Inquiry]\n//   - _inquiryService: normalized Product Inquiry string\n// Note: Does NOT set \"Forwarded to LLM\".\n\nfunction toList(value) {\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') return value.split(',').map(s => s.trim()).filter(Boolean);\n  if (value == null) return [];\n  return [String(value).trim()].filter(Boolean);\n}\n\nconst incoming = $input.all();\n\n// Split into sales vs mapping\nconst sales = [];\nconst mapping = [];\n\nfor (const it of incoming) {\n  const j = it.json || {};\n  const hasSalesKeys =\n    ('Client Id' in j) ||\n    ('Client Name' in j) ||\n    ('Client Email address' in j) ||\n    ('Product Inquiry' in j);\n  const hasMapKeys =\n    ('Pure Storage Service' in j) ||\n    ('Associated Products' in j);\n\n  if (hasMapKeys && !hasSalesKeys) mapping.push(j);\n  else if (hasSalesKeys) sales.push(j);\n}\n\n// Build the recommended map: { serviceName -> Set(lowercase products) }\nconst recommendedMap = {};\nfor (const row of mapping) {\n  const svc = String(row['Pure Storage Service'] || '').trim();\n  if (!svc) continue;\n  const assoc = toList(row['Associated Products']).map(s => s.toLowerCase());\n  if (!recommendedMap[svc]) recommendedMap[svc] = new Set();\n  for (const a of assoc) recommendedMap[svc].add(a);\n}\n\n// Convert sets to arrays\nconst recommendedMapArr = {};\nfor (const k of Object.keys(recommendedMap)) {\n  recommendedMapArr[k] = Array.from(recommendedMap[k]);\n}\n\n// Produce one output item per sales row with inquiry-based approved list\nconst out = [];\nfor (let i = 0; i < sales.length; i++) {\n  const row = sales[i] || {};\n  const inquiry = String(row['Product Inquiry'] || '').trim();\n  const approvedForInquiry = Array.isArray(recommendedMapArr[inquiry]) ? recommendedMapArr[inquiry] : [];\n\n  out.push({\n    json: {\n      ...row,\n      _recommendedMap: recommendedMapArr,     // full dictionary for downstream reference\n      _approvedForInquiry: approvedForInquiry, // lowercase array for the inquiry\n      _inquiryService: inquiry\n      // Intentionally NOT setting \"Forwarded to LLM\"\n    },\n    pairedItem: { item: i }\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1168,
        3824
      ],
      "id": "5bc5fe34-7797-4020-9c54-ea31146d790c",
      "name": "BuildMap1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "412c2b66-7ebd-4a48-b184-47c9f545d321",
              "name": "Client Id",
              "value": "={{ $('If2').item.json[\"Client Id\"] }}",
              "type": "number"
            },
            {
              "id": "78cefd84-aa6a-49bf-8d91-977ad9a2e263",
              "name": "Client Name",
              "value": "={{ $('If2').item.json[\"Client Name\"] }}",
              "type": "string"
            },
            {
              "id": "3543d52c-a425-44db-890f-8460b497b760",
              "name": "Product Inquiry",
              "value": "={{ $('If2').item.json[\"Product Inquiry\"] }}",
              "type": "string"
            },
            {
              "id": "58f940df-7742-4d12-8bba-cfaa3befc254",
              "name": "choices[0].message.content",
              "value": "={{ $json.choices[0].message.content }}",
              "type": "string"
            },
            {
              "id": "d99f7239-16ea-4342-8c69-1fdac2187503",
              "name": "Forwarded to LLM",
              "value": "={{ $('If2').item.json[\"Forwarded to LLM\"] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1920,
        3888
      ],
      "id": "c1d53bee-d790-47c0-946e-f6f641a04851",
      "name": "Edit Fields1"
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM Output → finalize fields for Sales Record\n// - Sets \"Forwarded to LLM\" = \"Yes\"\n// - Capitalizes first letter of each recommendation\n// - Uses upstream IST Timestamp if present; else computes IST locally\n\n// If a Date & Time node set a field \"Timestamp\" (Asia/Kolkata), prefer that; else compute here.\nfunction toISOStringWithTz(date, tzMinutesOffset) {\n  const pad = n => String(Math.floor(Math.abs(n))).padStart(2, '0');\n  const local = new Date(date.getTime() + tzMinutesOffset * 60 * 1000);\n  const year = local.getUTCFullYear();\n  const month = pad(local.getUTCMonth() + 1);\n  const day = pad(local.getUTCDate());\n  const hours = pad(local.getUTCHours());\n  const minutes = pad(local.getUTCMinutes());\n  const seconds = pad(local.getUTCSeconds());\n  const sign = tzMinutesOffset >= 0 ? '+' : '-';\n  const hh = pad(tzMinutesOffset / 60);\n  const mm = pad(tzMinutesOffset % 60);\n  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${sign}${hh}:${mm}`;\n}\nfunction formatReadableIST(isoWithOffset) {\n  const [datePart, timeAndOffset] = isoWithOffset.split('T');\n  const time = timeAndOffset.slice(0, 8);\n  const offset = timeAndOffset.slice(8);\n  return `${datePart} ${time} IST (${offset})`;\n}\nconst IST_OFFSET_MIN = 330;\n\n// Safe JSON parse\nfunction safeParseJson(s) {\n  if (typeof s === 'object' && s !== null) return s;\n  if (typeof s !== 'string') return null;\n  try { return JSON.parse(s); } catch { return null; }\n}\n\nfunction capitalizeFirst(s) {\n  if (!s) return s;\n  const t = String(s).trim();\n  return t.charAt(0).toUpperCase() + t.slice(1);\n}\n\nconst out = [];\nconst items = $input.all();\n\nfor (let i = 0; i < items.length; i++) {\n  const j = items[i].json || {};\n\n  // Prefer upstream Date & Time node field if present (configured with Asia/Kolkata)\n  let readableIst = j.Timestamp;\n  if (!readableIst) {\n    const isoIst = toISOStringWithTz(new Date(), IST_OFFSET_MIN);\n    readableIst = formatReadableIST(isoIst);\n  }\n\n  // Common Perplexity response shapes\n  let content = j.content || j.message || j.data || j.result || j.text;\n  if (content && typeof content === 'object' && content.content) content = content.content;\n  if (Array.isArray(j.choices) && j.choices[0]?.message?.content) content = j.choices[0].message.content;\n\n  // Parse structured output\n  let payload = null;\n  if (typeof content === 'object' && content !== null) payload = content;\n  if (!payload) payload = safeParseJson(content);\n  if (!payload && typeof j === 'string') payload = safeParseJson(j);\n\n  // Extract with safe fallbacks\n  const recs = Array.isArray(payload?.recommendations) ? payload.recommendations : [];\n  const recsCap = recs.map(capitalizeFirst);\n  const subj = payload?.email_subject || 'Pure Storage recommendations tailored to your inquiry';\n  const body = payload?.email_body || `Hi ${j['Client Name'] || 'there'},\\n\\nHere are recommended Pure Storage offerings aligned to your inquiry. Happy to schedule a quick call to discuss fit and next steps.\\n\\nBest regards,\\nTeam`;\n\n  out.push({\n    json: {\n      'Client Id': j['Client Id'],\n      'Client Name': j['Client Name'],\n      'Client Email address': j['Client Email address'],\n      'Product Inquiry': j['Product Inquiry'],\n      'Product Recommended': recsCap.join(', '),\n      'Forwarded to LLM': 'Yes',             \n      'Email Message': `Subject: ${subj}\\n\\n${body}`,\n      'Timestamp': readableIst\n    },\n    pairedItem: { item: i }\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2112,
        3888
      ],
      "id": "17488719-de99-4105-9d04-3847936044c7",
      "name": "Parse LLM Output"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "1293f28b-9927-4d96-9b76-8a7a8c527156",
              "leftValue": "={{ $json[\"Forwarded to LLM\"] }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "empty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1344,
        3824
      ],
      "id": "6af85ef9-67e0-4763-91a1-2b3b95f8dc10",
      "name": "If2"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1552,
        3808
      ],
      "id": "e15b99ff-07dc-491f-b932-08424b9bc01b",
      "name": "Loop Over Items2"
    },
    {
      "parameters": {
        "content": "Lead Recommendation_v3",
        "height": 432,
        "width": 1936
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        352,
        4528
      ],
      "id": "1dfc3b9e-7bed-40c4-bba9-490fffe46b39",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw",
          "mode": "list",
          "cachedResultName": "Lead Recommendation Sample data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1715613241,
          "mode": "list",
          "cachedResultName": "Recommendation list_v2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1y7jcrKOeskvI1Po_anS5U9QenZgf-e-oPzMiliPwZOw/edit#gid=1715613241"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        688,
        4752
      ],
      "id": "ab5275ac-f088-4a30-a65c-4b6282491dac",
      "name": "Get row(s) in sheet5",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        912,
        4688
      ],
      "id": "3fa163f6-5949-4a86-ad33-9be1a4effeb2",
      "name": "Merge3"
    },
    {
      "parameters": {
        "model": "sonar",
        "messages": {
          "message": [
            {
              "content": "=You are a sales enablement and storage domain assistant specialized in Pure Storage offerings. Recommend complementary Pure Storage products strictly from the approved list provided for the client’s inquired service, then compose a concise, conversion-focused cold email. Return strictly valid JSON in the exact schema requested. Do not include markdown, commentary, citations, or extra keys.",
              "role": "system"
            },
            {
              "content": "=Context:\n\nClient Id: {{ $json.Client_Id__c }}\n\nCompany: {{ $json.Company }}\n\nClient Name: {{ $json.Name }}\n\nEmail: {{ $json.Email }}\n\nProduct Inquiry: {{ $json.Product_Inquiry__c }}\n\nApproved recommendation list for this service:\n{{ $json._approvedForInquiry }}\n\nTask:\n\nPropose 4–6 “Product Recommended” using only items from the approved list above; output as a plain array of strings.\n\nWrite a personalized, professional cold email about these recommendations. Keep it 120–170 words, include a subject line, greet by name, highlight clear value, add a concrete next step, and a friendly sign-off.\n\nOutput JSON ONLY in this exact shape:\n{\n\"recommendations\": [\"...\",\"...\"],\n\"email_subject\": \"...\",\n\"email_body\": \"...\"\n}\n\nNotes:\n\nIf the approved list is empty or missing, still return valid JSON by selecting 4–6 widely adopted Pure Storage offerings aligned to the inquiry (e.g., FlashArray, FlashBlade, Pure1, Portworx, Cloud Block Store, Evergreen//One).\n\nTip: If available in the Perplexity node, set response_format to a JSON schema enforcing:\n{\ntype: \"object\",\nproperties: {\nrecommendations: { type: \"array\", items: { type: \"string\" }, minItems: 4, maxItems: 6 },\nemail_subject: { type: \"string\" },\nemail_body: { type: \"string\" }\n},\nrequired: [\"recommendations\",\"email_subject\",\"email_body\"],\nadditionalProperties: false\n}\nto increase compliance."
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexity",
      "typeVersion": 1,
      "position": [
        1728,
        4736
      ],
      "id": "488835ae-a23e-4881-8049-ce05340f105d",
      "name": "Message a model2",
      "credentials": {
        "perplexityApi": {
          "id": "2X923WJEbWR6QPD5",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Code node: Map recommendations to leads\n// Input: Mixed items from Salesforce Get Many (Lead) and Google Sheets (recommendation list)\n// Output: One item per lead with _recommendedMap, _approvedForInquiry, _inquiryService\n\nfunction toList(value) {\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') {\n    return value.split(',').map(s => s.trim()).filter(Boolean);\n  }\n  if (value == null) return [];\n  return [String(value).trim()].filter(Boolean);\n}\n\nfunction lcArray(arr) {\n  return toList(arr).map(s => String(s).toLowerCase());\n}\n\nfunction pick(obj, keys) {\n  const out = {};\n  for (const k of keys) if (k in obj) out[k] = obj[k];\n  return out;\n}\n\nconst incoming = $input.all();\n\n// Separate into Lead rows and Recommendation rows\nconst leads = [];\nconst recRows = [];\n\nfor (const item of incoming) {\n  const j = item.json ?? {};\n\n  const isLead =\n    // From Salesforce: attributes.type === 'Lead' or presence of typical Lead keys\n    (j?.attributes?.type === 'Lead') ||\n    ('Product_Inquiry__c' in j) ||\n    ('Status' in j) ||\n    ('Company' in j && ('Email' in j || 'Name' in j));\n\n  const isRec =\n    ('Pure Storage Service' in j) ||\n    ('Associated Products' in j);\n\n  if (isRec && !isLead) {\n    recRows.push(j);\n  } else if (isLead) {\n    leads.push(j);\n  }\n}\n\n// Build service -> Set(products lowercase)\nconst recommendedMap = {};\nfor (const row of recRows) {\n  const svc = String(row['Pure Storage Service'] ?? '').trim();\n  if (!svc) continue;\n  const assoc = lcArray(row['Associated Products']);\n  if (!recommendedMap[svc]) recommendedMap[svc] = new Set();\n  for (const p of assoc) recommendedMap[svc].add(p);\n}\n\n// Convert Sets to arrays for output\nconst recommendedMapArr = {};\nfor (const k of Object.keys(recommendedMap)) {\n  recommendedMapArr[k] = Array.from(recommendedMap[k]);\n}\n\n// Field normalization for leads coming from different sources\nfunction normalizeLead(row) {\n  // Prefer Salesforce API names when present\n  const norm = {\n    ClientId: row.Client_Id__c ?? row['Client Id'] ?? row['ClientId'] ?? row['Id'] ?? row['Lead Id'],\n    Company: row.Company ?? row['Company'],\n    Name: row.Name ?? row['Client Name'] ?? row['Full Name'],\n    Email: row.Email ?? row['Client Email address'] ?? row['Email Address'],\n    Phone: row.Phone ?? row['Phone'] ?? row['MobilePhone'],\n    Status: row.Status ?? row['Lead Status'] ?? row['Status'],\n  };\n\n  // Product Inquiry could be custom API name or human label\n  const inquiry =\n    row.Product_Inquiry__c ??\n    row['Product Inquiry'] ??\n    row['Pure Storage Service'] ?? // fallback if the lead already carries service column\n    '';\n\n  norm.ProductInquiry = String(inquiry ?? '').trim();\n\n  return { ...row, ...norm };\n}\n\n// Produce output: one per lead with approved products\nconst out = [];\n\nfor (let i = 0; i < leads.length; i++) {\n  const row = normalizeLead(leads[i] ?? {});\n  const inquiry = row.ProductInquiry;\n\n  const approvedForInquiry = Array.isArray(recommendedMapArr[inquiry])\n    ? recommendedMapArr[inquiry]\n    : [];\n\n  // Keep original row data, add normalized fields and mappings\n  out.push({\n    json: {\n      ...row,\n      _recommendedMap: recommendedMapArr,\n      _approvedForInquiry: approvedForInquiry,\n      _inquiryService: inquiry\n    },\n    pairedItem: { item: i }\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1104,
        4688
      ],
      "id": "eab9dcc7-072f-43f6-831f-8f946125daff",
      "name": "BuildMap2"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7c75946f-9dea-4e54-9a5b-60cc6c0cac2f",
              "name": "Id",
              "value": "={{ $('If5').item.json.Id }}",
              "type": "string"
            },
            {
              "id": "2a278ebd-bb29-472d-805d-bff0f5f67725",
              "name": "Client_Id__c",
              "value": "={{ $('If5').item.json.Client_Id__c }}",
              "type": "number"
            },
            {
              "id": "a808c87e-bf77-4b65-b610-72a1009c8d1d",
              "name": "Company",
              "value": "={{ $('If5').item.json.Company }}",
              "type": "string"
            },
            {
              "id": "78cefd84-aa6a-49bf-8d91-977ad9a2e263",
              "name": "Name",
              "value": "={{ $('If5').item.json.Name }}",
              "type": "string"
            },
            {
              "id": "d99f7239-16ea-4342-8c69-1fdac2187503",
              "name": "Status",
              "value": "={{ $('If5').item.json.Status }}",
              "type": "string"
            },
            {
              "id": "3543d52c-a425-44db-890f-8460b497b760",
              "name": "Product Inquiry",
              "value": "={{ $('If5').item.json.ProductInquiry }}",
              "type": "string"
            },
            {
              "id": "58f940df-7742-4d12-8bba-cfaa3befc254",
              "name": "choices[0].message.content",
              "value": "={{ $json.choices[0].message.content }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1904,
        4736
      ],
      "id": "a27ca5cf-f8bf-4077-b2a7-3e4b95c937ac",
      "name": "Edit Fields2"
    },
    {
      "parameters": {
        "jsCode": "// === LLM Parsing & Mapping Code Node (Clean Output with Lead ID + Proper Email) ===\n\nconst IST_OFFSET_MIN = 330; // +05:30 IST\n\n// ---------- Utilities ----------\nfunction toISOStringWithTz(date, tzMinutesOffset) {\n  const pad = (n) => String(Math.floor(Math.abs(n))).padStart(2, '0');\n  const local = new Date(date.getTime() + tzMinutesOffset * 60 * 1000);\n  const year = local.getUTCFullYear();\n  const month = pad(local.getUTCMonth() + 1);\n  const day = pad(local.getUTCDate());\n  const hours = pad(local.getUTCHours());\n  const minutes = pad(local.getUTCMinutes());\n  const seconds = pad(local.getUTCSeconds());\n  const sign = tzMinutesOffset >= 0 ? '+' : '-';\n  const offH = pad(Math.trunc(Math.abs(tzMinutesOffset) / 60));\n  const offM = pad(Math.abs(tzMinutesOffset) % 60);\n  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${sign}${offH}:${offM}`;\n}\n\nfunction formatReadableIST(isoWithOffset) {\n  const [datePart, timeAndOffset] = isoWithOffset.split('T');\n  const time = timeAndOffset.slice(0, 8);\n  const offset = timeAndOffset.slice(8);\n  return `${datePart} ${time} IST (${offset})`;\n}\n\nfunction safeParseJson(s) {\n  if (typeof s === 'object' && s !== null) return s;\n  if (typeof s !== 'string') return null;\n  let t = s.trim();\n  if (t.startsWith('```')) {\n    t = t.replace(/^```(?:json)?/i, '').replace(/```$/, '');\n  }\n  try {\n    return JSON.parse(t);\n  } catch {\n    try {\n      const fixed = t.replace(/,\\s*([}$$])/g, '$1');\n      return JSON.parse(fixed);\n    } catch {\n      return null;\n    }\n  }\n}\n\nfunction capitalizeFirst(s) {\n  if (!s) return s;\n  const t = String(s).trim();\n  return t.charAt(0).toUpperCase() + t.slice(1);\n}\n\nfunction extractContent(j) {\n  if (Array.isArray(j.choices) && j.choices.length > 0 && j.choices[0].message?.content) {\n    return j.choices[0].message.content;\n  }\n  if (typeof j.content === 'string') return j.content;\n  if (typeof j.message === 'string') return j.message;\n  if (typeof j.result === 'string') return j.result;\n  if (typeof j.text === 'string') return j.text;\n  return null;\n}\n\n// ---------- Main Processing ----------\nconst items = $input.all();\nconst out = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const j = items[i].json ?? {};\n\n  // --- Timestamp ---\n  let tsReadable = j.Timestamp__c || j.Timestamp;\n  if (!tsReadable) {\n    const isoIst = toISOStringWithTz(new Date(), IST_OFFSET_MIN);\n    tsReadable = formatReadableIST(isoIst);\n  }\n\n  // --- Extract & Parse LLM Output ---\n  const rawContent = extractContent(j);\n  const payload = (typeof rawContent === 'object' && rawContent !== null) \n    ? rawContent \n    : safeParseJson(rawContent);\n\n  // --- Recommendations ---\n  const recs = Array.isArray(payload?.recommendations) ? payload.recommendations : [];\n  const recsCap = recs.map(capitalizeFirst);\n  const productRecommended = recsCap.join(', ');\n\n  // --- Email Message (well-formatted) ---\n  const subj = typeof payload?.email_subject === 'string' ? payload.email_subject.trim() : null;\n  const body = typeof payload?.email_body === 'string' ? payload.email_body.trim() : null;\n  const name = j.Name || \"there\";\n\n  let emailMessageValue = \"\";\n\n  if (subj) {\n    emailMessageValue += `Subject: ${subj}\\n\\n`;\n  }\n\n  if (body) {\n    // Ensure greeting is present\n    if (!/^hi|hello/i.test(body)) {\n      emailMessageValue += `Hi ${name},\\n\\n`;\n    }\n    emailMessageValue += body;\n    if (!/best regards|thanks|sincerely/i.test(body.toLowerCase())) {\n      emailMessageValue += `\\n\\nBest regards,\\n\\n[Your Name]`;\n    }\n  } else {\n    emailMessageValue += `Hi ${name},\\n\\nI wanted to follow up regarding your inquiry.\\n\\nBest regards,\\n\\n[Your Name]`;\n  }\n\n  // --- Lead ID Handling ---\n  const leadId = j.LeadID || j.Lead_ID__c || j.Id || j.ID || null;\n\n  // --- Build Clean Output ---\n  const result = {\n    LeadID: leadId,\n    Client_Id__c: j.Client_Id__c,\n    Name: j.Name,\n    Email: j.Email,\n    Company: j.Company,\n    \"Product Inquiry\": j[\"Product Inquiry\"],\n    Status: \"Contacted\",\n    Product_Recommended__c: productRecommended,\n    Timestamp__c: tsReadable,\n    Email_Message__c: emailMessageValue,\n  };\n\n  out.push({\n    json: result,\n    pairedItem: { item: i },\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2096,
        4736
      ],
      "id": "840a5e29-a94b-4562-96bb-15611d8f2a16",
      "name": "Parse LLM Output1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "1293f28b-9927-4d96-9b76-8a7a8c527156",
              "leftValue": "={{ $json.Status }}",
              "rightValue": "New",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1280,
        4688
      ],
      "id": "18564109-6a8a-4824-b140-89e983cb009a",
      "name": "If5"
    },
    {
      "parameters": {
        "operation": "getAll",
        "limit": 100,
        "options": {
          "fields": "ID, Client_Id__c, Company, Name, Email, Product_Inquiry__c, Status"
        }
      },
      "type": "n8n-nodes-base.salesforce",
      "typeVersion": 1,
      "position": [
        688,
        4624
      ],
      "id": "52769065-e98e-4224-a77a-ee7192bfa253",
      "name": "Get many leads",
      "credentials": {
        "salesforceOAuth2Api": {
          "id": "KoZCB5WPo7sGMVF9",
          "name": "Salesforce account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "leadId": "={{ $json.LeadID }}",
        "updateFields": {
          "customFieldsUi": {
            "customFieldsValues": [
              {
                "fieldId": "Email_Message__c",
                "value": "={{ $json.Email_Message__c }}"
              },
              {
                "fieldId": "Product_Recommended__c",
                "value": "={{ $json.Product_Recommended__c }}"
              },
              {
                "fieldId": "Timestamp__c",
                "value": "={{ $json.Timestamp__c }}"
              }
            ]
          },
          "status": "Contacted"
        }
      },
      "type": "n8n-nodes-base.salesforce",
      "typeVersion": 1,
      "position": [
        1744,
        4560
      ],
      "id": "4bba3e61-e6be-4a38-8f08-3ae92ff2c22c",
      "name": "Update a lead",
      "credentials": {
        "salesforceOAuth2Api": {
          "id": "KoZCB5WPo7sGMVF9",
          "name": "Salesforce account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1520,
        4672
      ],
      "id": "d25cda0f-6564-42e6-b8aa-cf691fa5b03d",
      "name": "Loop Over Items3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        464,
        4704
      ],
      "id": "ee4383e6-be79-402e-8f07-393e787c979b",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {}
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        560,
        3824
      ],
      "id": "4690c29f-94db-42e2-9ecc-6a3af138112c",
      "name": "Schedule Trigger"
    }
  ],
  "pinData": {},
  "connections": {
    "Get Document URL4": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get document4": {
      "main": [
        [
          {
            "node": "Set Doc Id1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output4": {
      "main": [
        [
          {
            "node": "Store the Output4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store the Output4": {
      "main": [
        [
          {
            "node": "Limit8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get ID4": {
      "main": [
        [
          {
            "node": "Merge Reference URL1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [
          {
            "node": "Limit7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Id and URL3": {
      "main": [
        [
          {
            "node": "Merge All Data1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Limit7": {
      "main": [
        [
          {
            "node": "Merge Reference URL1",
            "type": "main",
            "index": 1
          },
          {
            "node": "Get document4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit8": {
      "main": [
        [
          {
            "node": "Update URLs to scrape sheet2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Final Deduplication": {
      "main": [
        [
          {
            "node": "Merge All Data1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler Node1": {
      "main": [
        [
          {
            "node": "Flatten Output1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Accumulator Node1": {
      "main": [
        [
          {
            "node": "Final Deduplication",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation1": {
      "main": [
        [
          {
            "node": "Accumulator Node1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Case Integrity Check1": {
      "main": [
        [
          {
            "node": "Validation1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Subindustry Enricher1": {
      "main": [
        [
          {
            "node": "Use Case Integrity Check1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Id and URL1": {
      "main": [
        [
          {
            "node": "Set Id and URL3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Doc Id1": {
      "main": [
        [
          {
            "node": "Update URLs to scrape sheet2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Passing Use Cases only from Content1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Reference URL1": {
      "main": [
        [
          {
            "node": "Get Id and URL1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Data1": {
      "main": [
        [
          {
            "node": "Structured Output4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update URLs to scrape sheet2": {
      "main": [
        [
          {
            "node": "If4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Flatten Output1": {
      "main": [
        [
          {
            "node": "Subindustry Enricher1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM1": {
      "main": [
        [
          {
            "node": "Error Handler Node1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Passing Use Cases only from Content1": {
      "main": [
        [
          {
            "node": "LLM1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get content1": {
      "main": [
        [
          {
            "node": "Universal Content Analyzer1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Create Google Docs1": {
      "main": [
        [
          {
            "node": "Save Text to Google Docs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Text to Google Docs1": {
      "main": [
        [
          {
            "node": "Update Google Sheets2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Text to Google Docs": {
      "main": [
        [
          {
            "node": "Update Google Sheets2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Google Docs1": {
      "main": [
        [
          {
            "node": "Update Text to Google Docs1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Google Sheets2": {
      "main": [
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get URLs to scrape1": {
      "main": [
        [
          {
            "node": "If9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If7": {
      "main": [
        [
          {
            "node": "Get Google Docs1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Google Docs1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Structured Output1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If9": {
      "main": [
        [
          {
            "node": "Limit9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Universal Content Analyzer1": {
      "main": [
        [
          {
            "node": "Get Structured Output1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "If4": {
      "main": [
        [
          {
            "node": "Update URLs to scrape sheet3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code3": {
      "main": [
        [
          {
            "node": "If7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine": {
      "main": [
        [
          {
            "node": "Code3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Combine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit9": {
      "main": [
        [
          {
            "node": "Scrape a url and get its content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape a url and get its content": {
      "main": [
        [
          {
            "node": "Get content1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Document URL": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get document": {
      "main": [
        [
          {
            "node": "Set Doc Id",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output": {
      "main": [
        [
          {
            "node": "Store the Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store the Output": {
      "main": [
        [
          {
            "node": "Limit4",
            "type": "main",
            "index": 0
          },
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get ID": {
      "main": [
        [
          {
            "node": "Merge Reference URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Id and URL": {
      "main": [
        [
          {
            "node": "Merge All Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Limit": {
      "main": [
        [
          {
            "node": "Merge Reference URL",
            "type": "main",
            "index": 1
          },
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit4": {
      "main": [
        [
          {
            "node": "Update URLs to scrape sheet",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Chunk Document": {
      "main": [
        [
          {
            "node": "Universal Smart Gatekeeper",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Final Deduplication1": {
      "main": [
        [
          {
            "node": "Merge All Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler Node": {
      "main": [
        [
          {
            "node": "LLM Output Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Accumulator Node": {
      "main": [
        [
          {
            "node": "Final Deduplication1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation": {
      "main": [
        [
          {
            "node": "Accumulator Node",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Universal Smart Gatekeeper": {
      "main": [
        [
          {
            "node": "Merge Chunks with generated output",
            "type": "main",
            "index": 0
          },
          {
            "node": "Pre Grounding Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pre Grounding Filter": {
      "main": [
        [
          {
            "node": "LLM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post Grounding Filter": {
      "main": [
        [
          {
            "node": "Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Output Validator": {
      "main": [
        [
          {
            "node": "Merge Chunks with generated output",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Use Case Integrity Check": {
      "main": [
        [
          {
            "node": "Post Grounding Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Subindustry Enricher": {
      "main": [
        [
          {
            "node": "Use Case Integrity Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Id and URL": {
      "main": [
        [
          {
            "node": "Set Id and URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Doc Id": {
      "main": [
        [
          {
            "node": "Update URLs to scrape sheet",
            "type": "main",
            "index": 0
          },
          {
            "node": "Chunk Document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Reference URL": {
      "main": [
        [
          {
            "node": "Get Id and URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Data": {
      "main": [
        [
          {
            "node": "Structured Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update URLs to scrape sheet": {
      "main": [
        [
          {
            "node": "Update URLs to scrape sheet1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Chunks with generated output": {
      "main": [
        [
          {
            "node": "Flatten Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Flatten Output": {
      "main": [
        [
          {
            "node": "Subindustry Enricher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM": {
      "main": [
        [
          {
            "node": "Error Handler Node",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items1": {
      "main": [
        [],
        [
          {
            "node": "Get document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get row(s) in sheet": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get row(s) in sheet1": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "BuildMap",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript3": {
      "main": [
        [
          {
            "node": "Append or update row in sheet1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BuildMap": {
      "main": [
        [
          {
            "node": "MatchPerRow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MatchPerRow": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Code in JavaScript3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Output": {
      "main": [
        [
          {
            "node": "Append or update row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Format Output",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get row(s) in sheet2": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get row(s) in sheet3": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "BuildMap1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model1": {
      "main": [
        [
          {
            "node": "Edit Fields1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BuildMap1": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields1": {
      "main": [
        [
          {
            "node": "Parse LLM Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LLM Output": {
      "main": [
        [
          {
            "node": "Loop Over Items2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Append or update row in sheet2": {
      "main": [
        []
      ]
    },
    "If2": {
      "main": [
        [
          {
            "node": "Loop Over Items2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items2": {
      "main": [
        [
          {
            "node": "Append or update row in sheet2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Message a model1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get row(s) in sheet5": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "BuildMap2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model2": {
      "main": [
        [
          {
            "node": "Edit Fields2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BuildMap2": {
      "main": [
        [
          {
            "node": "If5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields2": {
      "main": [
        [
          {
            "node": "Parse LLM Output1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LLM Output1": {
      "main": [
        [
          {
            "node": "Loop Over Items3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If5": {
      "main": [
        [
          {
            "node": "Loop Over Items3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many leads": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items3": {
      "main": [
        [
          {
            "node": "Update a lead",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Message a model2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Get many leads",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get row(s) in sheet5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get row(s) in sheet2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get row(s) in sheet3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "26a5ffed-e31d-4b9d-85bb-10f4f2ae926f",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "bfcd6787278013c4297eab9e02ba1b471bfeb33559859e03b602b2c606ee76d9"
  },
  "id": "RceyNe2PhvJkZCuj",
  "tags": []
}