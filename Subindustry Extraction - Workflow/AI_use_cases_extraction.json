{
  "nodes": [
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1663435215,
          "mode": "list",
          "cachedResultName": "Copy of Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=1663435215"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        -896,
        1024
      ],
      "id": "fa72c7b1-777f-4569-a138-24a97ddd4bd5",
      "name": "Get Document URL4",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "documentURL": "={{ $json[\"Document ID\"] }}"
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        -288,
        1008
      ],
      "id": "2cfbe6bb-151d-4e56-a337-91cbaa1a61f5",
      "name": "Get document4",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Structured Output (final form for sheet/db ingest)\n// - Reads a control item with highestIdNum/nextIdNum and url/URL\n// - Assigns Ids (UC{n}), sets References=controlUrl, normalizes Other_References\n// - Adds Timestamp in IST; outputs only use-case rows\nconst toStr = v => (v == null ? \"\" : String(v));\nconst normalizeRefs = v => Array.isArray(v)\n  ? v.map(x => toStr(x).trim()).filter(Boolean).join(\"; \")\n  : toStr(v).trim();\n\nconst getIST = () => {\n  const ist = new Date(Date.now() + 5.5 * 3600 * 1000);\n  const y = ist.getUTCFullYear();\n  const m = String(ist.getUTCMonth() + 1).padStart(2, \"0\");\n  const d = String(ist.getUTCDate()).padStart(2, \"0\");\n  const hh = String(ist.getUTCHours()).padStart(2, \"0\");\n  const mm = String(ist.getUTCMinutes()).padStart(2, \"0\");\n  const ss = String(ist.getUTCSeconds()).padStart(2, \"0\");\n  return `'${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n};\n\n// Identify control item\nlet highestIdNum = 0;\nlet controlUrl = \"\";\nfor (const it of $items()) {\n  const j = it.json || {};\n  if (j.highestIdNum != null || j.nextIdNum != null || j.url != null || j.URL != null) {\n    const n = parseInt(j.highestIdNum ?? j.nextIdNum ?? \"0\", 10);\n    highestIdNum = Number.isNaN(n) ? 0 : n;\n    controlUrl = (toStr(j.url ?? j.URL) || \"\").trim();\n    break;\n  }\n}\n\nconst prefix = \"UC\";\nlet counter = highestIdNum + 1;\n\n// Collect only use case items (exclude control)\nconst data = $items()\n  .map(it => it.json)\n  .filter(j => j && j.Industry && j.Title_Of_AI_Use_Case && !(\"highestIdNum\" in j) && !(\"nextIdNum\" in j));\n\nconst out = data.map(u => {\n  const otherRefsNormalized = normalizeRefs(\n    u.Other_References ?? u.OtherReferences ?? u[\"Other References\"] ?? u.References ?? \"\"\n  ) || controlUrl;\n\n  return {\n    json: {\n      Id: `${prefix}${counter++}`,\n      Industry: toStr(u.Industry),\n      Subindustry: toStr(u.Subindustry),\n      Business_Function: toStr(u.Business_Function),\n      Business_Capability: toStr(u.Business_Capability),\n      Stakeholder_Or_User: toStr(u.Stakeholder_Or_User),\n      Companies_Involved: toStr(u.Companies_Involved ?? \"\"),\n      Title_Of_AI_Use_Case: toStr(u.Title_Of_AI_Use_Case),\n      Description: toStr(u.Description),\n      Impact: toStr(u.Impact),\n      Action_Implementation_Plan: toStr(u.Action_Implementation_Plan),\n      Expected_Outcomes_And_Results: toStr(u.Expected_Outcomes_And_Results),\n      Datasets: toStr(u.Datasets),\n      AI_Capabilities_And_Tech: toStr(u.AI_Capabilities_And_Tech),\n      Digital_Platforms_And_Tools_And_Models: toStr(u.Digital_Platforms_And_Tools_And_Models),\n      AI_Algo_And_Frameworks: toStr(u.AI_Algo_And_Frameworks),\n      References: controlUrl,\n      Other_References: otherRefsNormalized,\n      Timestamp: getIST()\n    }\n  };\n});\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        656,
        1280
      ],
      "id": "df4c71ad-505b-4611-b68f-d52e205690d9",
      "name": "Structured Output4",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k",
          "mode": "list",
          "cachedResultName": "AI_Use_cases_Perplexity",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 495948948,
          "mode": "list",
          "cachedResultName": "Perplexity LLM Generated Output Data_v2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit#gid=495948948"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Id": "={{ $json.Id }}",
            "Industry": "={{ $json.Industry }}",
            "Subindustry": "={{ $json.Subindustry }}",
            "Business_Function": "={{ $json.Business_Function }}",
            "Business_Capability": "={{ $json.Business_Capability }}",
            "Stakeholder_Or_User": "={{ $json.Stakeholder_Or_User }}",
            "Description": "={{ $json.Description }}",
            "Impact": "={{ $json.Impact }}",
            "Action_Implementation_Plan": "={{ $json.Action_Implementation_Plan }}",
            "Expected_Outcomes_And_Results": "={{ $json.Expected_Outcomes_And_Results }}",
            "Datasets": "={{ $json.Datasets }}",
            "Timestamp": "={{ $json.Timestamp }}",
            "References": "={{ $json.References }}",
            "AI_Algo_And_Frameworks": "={{ $json.AI_Algo_And_Frameworks }}",
            "AI_Capabilities_And_Tech": "={{ $json.AI_Capabilities_And_Tech }}",
            "Title_Of_AI_Use_Case": "={{ $json.Title_Of_AI_Use_Case }}",
            "Other_References": "={{ $json.Other_References }}",
            "Digital_Platforms_And_Tools_And_Models": "={{ $json.Digital_Platforms_And_Tools_And_Models }}"
          },
          "matchingColumns": [
            "Id"
          ],
          "schema": [
            {
              "id": "Id",
              "displayName": "Id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Industry",
              "displayName": "Industry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Subindustry",
              "displayName": "Subindustry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Business_Function",
              "displayName": "Business_Function",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Business_Capability",
              "displayName": "Business_Capability",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Stakeholder_Or_User",
              "displayName": "Stakeholder_Or_User",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Title_Of_AI_Use_Case",
              "displayName": "Title_Of_AI_Use_Case",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Description",
              "displayName": "Description",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Impact",
              "displayName": "Impact",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Action_Implementation_Plan",
              "displayName": "Action_Implementation_Plan",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Expected_Outcomes_And_Results",
              "displayName": "Expected_Outcomes_And_Results",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Datasets",
              "displayName": "Datasets",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "AI_Capabilities_And_Tech",
              "displayName": "AI_Capabilities_And_Tech",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Digital_Platforms_And_Tools_And_Models",
              "displayName": "Digital_Platforms_And_Tools_And_Models",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "AI_Algo_And_Frameworks",
              "displayName": "AI_Algo_And_Frameworks",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "References",
              "displayName": "References",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Other_References",
              "displayName": "Other_References",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Timestamp",
              "displayName": "Timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        912,
        1280
      ],
      "id": "65967c9e-28fb-456e-9828-81ab0907b0f9",
      "name": "Store the Output4",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k",
          "mode": "list",
          "cachedResultName": "AI_Use_cases_Perplexity",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 495948948,
          "mode": "list",
          "cachedResultName": "Perplexity LLM Generated Output Data_v2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1ef8s9qSwzJtfDz7IbkieKBLorNBbi53i2VH25WbKz3k/edit#gid=495948948"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        -896,
        1280
      ],
      "id": "0338269d-4a95-4ef2-9930-bfe436cff7aa",
      "name": "Get ID4",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "content": "## Getting Output From Scraped Data LLM Generated output_v3",
        "height": 560,
        "width": 3168,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1152,
        912
      ],
      "id": "54a5bf2e-47b0-4221-9428-a0cca2e034d1",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "1b63c677-ce12-48ea-9d25-701fb30a5b98",
              "leftValue": "={{ $json[\"Generated Output\"] }}",
              "rightValue": " No",
              "operator": {
                "type": "string",
                "operation": "empty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -720,
        1024
      ],
      "id": "594cc384-634c-4477-9b78-acbf465973c6",
      "name": "If3"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "6e9612d3-1d33-4252-8978-53c54663689c",
              "name": "url",
              "value": "={{ $json.url }}",
              "type": "string"
            },
            {
              "id": "912b10d3-fcb4-442c-ba52-b89ec175a0eb",
              "name": "highestIdNum",
              "value": "={{ $json.highestIdNum }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        48,
        1296
      ],
      "id": "9e444e92-2964-45e6-9546-1ef98029c21c",
      "name": "Set Id and URL3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        -528,
        1008
      ],
      "id": "cb9bbf94-ff75-4cff-9fc4-a583801830a3",
      "name": "Limit7"
    },
    {
      "parameters": {
        "keep": "lastItems"
      },
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        1104,
        1280
      ],
      "id": "ea92cfec-1c18-4e17-a2d1-843f16cd4dbb",
      "name": "Limit8"
    },
    {
      "parameters": {
        "jsCode": "// Final Deduplication - improved fingerprint includes Subindustry\nconst toStr = v => (v == null ? \"\" : String(v));\n\nfunction normalizeForComparison(str) {\n  return toStr(str)\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\nfunction createFingerprint(uc) {\n  const core = `${uc.Industry} ${uc.Subindustry || \"\"} ${uc.Business_Function} ${uc.Title_Of_AI_Use_Case}`;\n  return normalizeForComparison(core);\n}\n\nfunction levenshteinDistance(a, b) {\n  const s1 = a.toLowerCase(), s2 = b.toLowerCase();\n  const costs = new Array(s2.length + 1);\n  for (let j = 0; j <= s2.length; j++) costs[j] = j;\n  for (let i = 1; i <= s1.length; i++) {\n    let lastValue = i;\n    for (let j = 1; j <= s2.length; j++) {\n      let newValue = costs[j - 1];\n      if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {\n        newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;\n      }\n      costs[j - 1] = lastValue;\n      lastValue = newValue;\n    }\n    costs[s2.length] = lastValue;\n  }\n  return costs[s2.length];\n}\n\nfunction similarity(a, b) {\n  const longer = a.length >= b.length ? a : b;\n  const shorter = a.length >= b.length ? b : a;\n  if (longer.length === 0) return 1.0;\n  const dist = levenshteinDistance(longer, shorter);\n  return (longer.length - dist) / longer.length;\n}\n\nfunction areDuplicates(uc1, uc2) {\n  const fp1 = createFingerprint(uc1);\n  const fp2 = createFingerprint(uc2);\n  if (fp1 === fp2) return true;\n  const titleSim = similarity(\n    normalizeForComparison(uc1.Title_Of_AI_Use_Case),\n    normalizeForComparison(uc2.Title_Of_AI_Use_Case)\n  );\n  return titleSim > 0.85;\n}\n\nfunction selectBetter(a, b) {\n  const d1 = toStr(a.Description).length;\n  const d2 = toStr(b.Description).length;\n  return d2 > d1 ? b : a;\n}\n\nconst inputItems = $input.all().map(i => i.json).filter(Boolean);\nconst unique = [];\nconsole.log(`Starting deduplication on ${inputItems.length} items`);\n\nfor (const uc of inputItems) {\n  let dup = false;\n  for (let i = 0; i < unique.length; i++) {\n    if (areDuplicates(uc, unique[i])) {\n      console.log(`Merging duplicate: \"${toStr(uc.Title_Of_AI_Use_Case)}\"`);\n      unique[i] = selectBetter(unique[i], uc);\n      dup = true; break;\n    }\n  }\n  if (!dup) unique.push(uc);\n}\n\nconsole.log(`Deduplication complete: ${inputItems.length} -> ${unique.length} unique`);\nreturn unique.map(uc => ({ json: uc }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        1008
      ],
      "id": "f391acd9-9614-4362-ae98-181db6f0d0b7",
      "name": "Final Deduplication"
    },
    {
      "parameters": {
        "jsCode": "// This ensures the loop continues even if individual API calls fail\n\nconst input = $input.all();\n\n// Check if we have valid data\nif (!input || input.length === 0) {\n  console.log(\"No input data - returning empty result to continue loop\");\n  return [{\n    json: {\n      message: \"[]\", // Empty JSON array for downstream processing\n      chunk_index: $json?.chunk_index || 0,\n      documentId: $json?.documentId || \"\",\n      content: $json?.content || \"\"\n    }\n  }];\n}\n\n// Check if the API response is valid\nconst firstItem = input[0];\nif (!firstItem.json?.message) {\n  console.log(\"Invalid API response - returning empty result\");\n  return [{\n    json: {\n      message: \"[]\",\n      chunk_index: firstItem.json?.chunk_index || 0,\n      documentId: firstItem.json?.documentId || \"\",\n      content: firstItem.json?.content || \"\"\n    }\n  }];\n}\n\n// Return the original data if valid\nreturn input;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        640,
        1008
      ],
      "id": "30fc61a4-331a-49cb-9638-0c9ff4693b60",
      "name": "Error Handler Node1"
    },
    {
      "parameters": {
        "jsCode": "// Accumulator Node - Simple pass-through collector\nconst allItems = $input.all();\nconsole.log(`Accumulator: Received ${allItems.length} items`);\n\nreturn allItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        1008
      ],
      "id": "baee1d30-179f-471e-9c96-65560690e042",
      "name": "Accumulator Node1"
    },
    {
      "parameters": {
        "jsCode": "// Final Validation and completion aligned to updated fields\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\nconst hasValue = v => toStr(v).length > 0;\n\nfunction splitItems(s) {\n  return toStr(s)\n    .replace(/\\s*;\\s*/g, \",\")\n    .replace(/\\s+and\\s+/gi, \",\")\n    .split(\",\")\n    .map(x => x.trim())\n    .filter(Boolean);\n}\n\nconst CONSERVATIVE_DEFAULTS = {\n  Digital_Platforms_And_Tools_And_Models: \"AWS SageMaker, Azure ML\",\n  AI_Capabilities_And_Tech: \"Predictive Analytics, Natural Language Processing\",\n  AI_Algo_And_Frameworks: \"Random Forest, Gradient Boosting\"\n};\n\nfunction ensureMinimums(uc) {\n  const out = { ...uc };\n\n  // Digital_Platforms_And_Tools_And_Models: ≤10 items, conservative defaults if empty\n  let dptm = splitItems(out.Digital_Platforms_And_Tools_And_Models);\n  if (dptm.length === 0) dptm = splitItems(CONSERVATIVE_DEFAULTS.Digital_Platforms_And_Tools_And_Models);\n  out.Digital_Platforms_And_Tools_And_Models = dptm.slice(0, 10).join(\", \");\n\n  // AI_Capabilities_And_Tech: ≥2\n  let caps = splitItems(out.AI_Capabilities_And_Tech);\n  if (caps.length < 2) {\n    const def = splitItems(CONSERVATIVE_DEFAULTS.AI_Capabilities_And_Tech);\n    caps = [...caps, ...def].slice(0, Math.max(2, caps.length + def.length));\n  }\n  out.AI_Capabilities_And_Tech = caps.join(\", \");\n\n  // AI_Algo_And_Frameworks: ≥2\n  let algos = splitItems(out.AI_Algo_And_Frameworks);\n  if (algos.length < 2) {\n    const def = splitItems(CONSERVATIVE_DEFAULTS.AI_Algo_And_Frameworks);\n    algos = [...algos, ...def].slice(0, Math.max(2, algos.length + def.length));\n  }\n  out.AI_Algo_And_Frameworks = algos.join(\", \");\n\n  return out;\n}\n\nfunction enforceLengths(uc) {\n  const out = { ...uc };\n  const desc = toStr(out.Description);\n  const words = desc.split(/\\s+/).filter(Boolean);\n  if (words.length < 70) {\n    console.log(`Short description (${words.length} words): ${toStr(out.Title_Of_AI_Use_Case)}`);\n  } else if (words.length > 150) {\n    out.Description = words.slice(0, 150).join(\" \") + \"...\";\n  }\n\n  if (out.Impact && out.Impact.length > 200) {\n    out.Impact = out.Impact.slice(0, 200).trim() + \"...\";\n  }\n  if (out.Expected_Outcomes_And_Results && out.Expected_Outcomes_And_Results.length > 200) {\n    out.Expected_Outcomes_And_Results = out.Expected_Outcomes_And_Results.slice(0, 200).trim() + \"...\";\n  }\n  return out;\n}\n\nfunction isValid(uc) {\n  return hasValue(uc.Title_Of_AI_Use_Case) &&\n         hasValue(uc.Description) &&\n         hasValue(uc.Industry) &&\n         toStr(uc.Description).length >= 50;\n}\n\nconst results = [];\nlet validCount = 0, invalidCount = 0;\n\nfor (const item of $input.all()) {\n  const uc = item.json;\n  if (!isValid(uc)) {\n    console.log(`Invalid use case: ${toStr(uc?.Title_Of_AI_Use_Case) || 'No title'}`);\n    invalidCount++;\n    continue;\n  }\n  let out = ensureMinimums(uc);\n  out = enforceLengths(out);\n  results.push({ json: out });\n  validCount++;\n}\nconsole.log(`Validation: ${validCount} valid, ${invalidCount} invalid`);\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1424,
        1008
      ],
      "id": "fca72efb-ee0e-4233-8338-6004a4f37f3b",
      "name": "Validation1"
    },
    {
      "parameters": {
        "jsCode": "// Use Case Integrity Check - updated to new schema\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\n\nfunction validateUseCase(uc) {\n  const errors = [];\n  if (!toStr(uc.Title_Of_AI_Use_Case)) errors.push(\"Missing title\");\n  const desc = toStr(uc.Description);\n  if (!desc || desc.length < 50) errors.push(\"Description too short or missing\");\n  if (!toStr(uc.Industry)) errors.push(\"Missing industry\");\n  // Companies_Involved must exist as string (empty allowed)\n  if (uc.Companies_Involved == null) errors.push(\"Missing Companies_Involved field\");\n  return errors;\n}\n\n// Ensure comma-separated normalization for tech fields\nconst TECH_FIELDS = [\n  \"AI_Capabilities_And_Tech\",\n  \"Digital_Platforms_And_Tools_And_Models\",\n  \"AI_Algo_And_Frameworks\"\n];\n\nfunction normalizeListField(s) {\n  if (!s) return \"\";\n  let v = String(s)\n    .replace(/\\s*;\\s*/g, \", \")\n    .replace(/\\s+and\\s+/gi, \", \")\n    .replace(/\\s*,\\s*/g, \", \")\n    .trim();\n  // collapse multiple commas\n  v = v.replace(/,+\\s*,+/g, \", \").replace(/\\s*,\\s*/g, \", \");\n  return v;\n}\n\nfunction cleanUseCase(uc) {\n  const cleaned = { ...uc };\n\n  // Stringify long-form fields safely\n  if (cleaned.Description != null) cleaned.Description = toStr(cleaned.Description);\n  if (cleaned.Impact != null) cleaned.Impact = toStr(cleaned.Impact);\n  if (cleaned.Expected_Outcomes_And_Results != null) cleaned.Expected_Outcomes_And_Results = toStr(cleaned.Expected_Outcomes_And_Results);\n\n  // Companies_Involved must be a string; if array -> comma string; if absent -> \"\"\n  if (Array.isArray(cleaned.Companies_Involved)) {\n    cleaned.Companies_Involved = cleaned.Companies_Involved.map(x => toStr(x)).filter(Boolean).join(\", \");\n  }\n  if (cleaned.Companies_Involved == null) cleaned.Companies_Involved = \"\";\n\n  // Normalize tech list fields\n  for (const f of TECH_FIELDS) {\n    if (cleaned[f]) cleaned[f] = normalizeListField(cleaned[f]);\n  }\n\n  // Other_References: normalize arrays/objects to semicolon string\n  if (Array.isArray(cleaned.Other_References)) {\n    cleaned.Other_References = cleaned.Other_References.map(x => toStr(x)).filter(Boolean).join(\"; \");\n  } else {\n    cleaned.Other_References = toStr(cleaned.Other_References);\n  }\n\n  return cleaned;\n}\n\nconst results = [];\nlet valid = 0, invalid = 0;\n\nfor (const item of $input.all()) {\n  const uc = item.json;\n  // Ensure presence of Companies_Involved field for validation consistency\n  if (uc && uc.Companies_Involved == null) uc.Companies_Involved = \"\";\n  const errors = validateUseCase(uc || {});\n  if (errors.length === 0) {\n    const cleaned = cleanUseCase(uc);\n    results.push({ json: cleaned });\n    valid++;\n  } else {\n    console.log(`Invalid use case: ${toStr(uc?.Title_Of_AI_Use_Case) || 'No title'} - ${errors.join(', ')}`);\n    invalid++;\n  }\n}\nconsole.log(`Integrity check: ${valid} valid, ${invalid} invalid`);\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1232,
        1008
      ],
      "id": "4d5932ca-7d77-4847-b5e8-643749eb9960",
      "name": "Use Case Integrity Check1"
    },
    {
      "parameters": {
        "jsCode": "// Subindustry Enricher - aligned with updated fallback library\nconst toStr = v => (v == null ? \"\" : String(v)).trim();\nconst hasValue = v => toStr(v).length > 2;\n\nconst FALLBACKS = {\n  finance: [\"Banking\", \"Insurance\", \"Wealth Management\"],\n  healthcare: [\"Health Care Providers\", \"Pharmaceuticals\", \"Biotechnology\"],\n  retail: [\"E‑Commerce\", \"Grocery\", \"Fashion\"],\n  manufacturing: [\"Automotive\", \"Electronics\", \"Industrial Machinery\"],\n  energy: [\"Energy\", \"Utilities\", \"Renewables\"],\n  telecom: [\"Telecommunications\", \"Network Operators\", \"Communications\"],\n  technology: [\"Software\", \"Data & AI Platforms\", \"Cloud Services\"]\n};\n\nfunction deriveSubindustry(industry, title, description) {\n  const text = `${toStr(industry)} ${toStr(title)} ${toStr(description)}`.toLowerCase();\n\n  // Context cues\n  if (/(predictive maintenance|condition monitoring|asset health)/i.test(text)) return \"Industrial Machinery\";\n  if (/(quality control|defect detection|computer vision qc)/i.test(text)) return \"Electronics\";\n  if (/(e-?commerce|recommendation|personalization|merchandising)/i.test(text)) return \"E‑Commerce\";\n  if (/(grocery|assortment|planogram)/i.test(text)) return \"Grocery\";\n  if (/(bank|credit|loan|card|transaction)/i.test(text)) return \"Banking\";\n  if (/(insurance|claims|underwriting|policy)/i.test(text)) return \"Insurance\";\n  if (/(hospital|clinical|ehr|patient|triage|diagnos)/i.test(text)) return \"Health Care Providers\";\n  if (/(pharma|drug|trial|compound|molecule)/i.test(text)) return \"Pharmaceuticals\";\n  if (/(grid|renewable|solar|wind|meter)/i.test(text)) return \"Energy\";\n\n  // Industry-based fallback\n  const ind = toStr(industry).toLowerCase();\n  for (const key of Object.keys(FALLBACKS)) {\n    if (ind.includes(key)) return FALLBACKS[key];\n  }\n  return \"\";\n}\n\nconst results = [];\nlet enrichedCount = 0;\n\nfor (const item of $input.all()) {\n  const uc = { ...(item.json || {}) };\n  if (!uc || !hasValue(uc.Title_Of_AI_Use_Case)) { results.push(item); continue; }\n  if (!hasValue(uc.Subindustry) && hasValue(uc.Industry)) {\n    const sub = deriveSubindustry(uc.Industry, uc.Title_Of_AI_Use_Case, uc.Description);\n    if (hasValue(sub)) {\n      uc.Subindustry = sub;\n      enrichedCount++;\n      console.log(`Added Subindustry: ${uc.Subindustry}`);\n    }\n  }\n  results.push({ json: uc });\n}\nconsole.log(`Subindustry enriched: ${enrichedCount} use cases`);\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        1008
      ],
      "id": "e507291d-1090-415a-ac0d-810f7f327015",
      "name": "Subindustry Enricher1"
    },
    {
      "parameters": {
        "jsCode": "// Utility: extract trailing integer from an Id string, tolerant of prefixes (e.g., \"UC12\", \"uc-007\", \"15\")\nfunction extractTrailingNumber(idStr) {\n  if (!idStr && idStr !== 0) return null;\n  const s = String(idStr).trim();\n  // Match last run of digits in the string\n  const m = s.match(/(\\d+)\\s*$/);\n  if (!m) return null;\n  const n = parseInt(m[1], 10);\n  return Number.isNaN(n) ? null : n;\n}\n\n// 1) Gather all incoming items\nconst items = $input.all();\n\n// 2) Find the highest numeric suffix from any \"Id\" fields\nlet maxNum = 0;\nfor (const it of items) {\n  const idVal =\n    it.json?.Id ??\n    it.json?.id ?? // be tolerant of lowercase\n    null;\n\n  const num = extractTrailingNumber(idVal);\n  if (num !== null && num > maxNum) {\n    maxNum = num;\n  }\n}\n\n// 3) Extract a URL to carry forward (Merge1 should provide an item with URL)\nlet foundUrl = \"\";\nfor (const it of items) {\n  const urlCandidate =\n    it.json?.URL ??\n    it.json?.Url ??\n    it.json?.url ??\n    \"\";\n  if (urlCandidate && String(urlCandidate).trim()) {\n    foundUrl = String(urlCandidate).trim();\n    break; // take the first non-empty URL\n  }\n}\n\n// 4) Prepare a single control item that downstream nodes can read\nconst controlItem = {\n  json: {\n    highestIdNum: maxNum,\n    nextIdNum: maxNum + 1,\n    url: foundUrl\n  }\n};\n\n// 5) Option A: return original items plus the control item (default)\n//return [...items, controlItem];\n\n// 5) Option B: if you prefer returning only the control item, replace the line above with:\n return [controlItem];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -144,
        1296
      ],
      "id": "7fe60955-8716-42b4-b4fe-969daae1daff",
      "name": "Get Id and URL1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "14bf176b-4bdc-460e-9936-64e71a8458cd",
              "name": "documentId",
              "value": "={{ $json.documentId }}",
              "type": "string"
            },
            {
              "id": "1bd1a34f-16ab-4cb8-a0b2-9baee8ec73b5",
              "name": "determinedAs",
              "value": "={{ $('Get Document URL4').item.json.determinedAs }}",
              "type": "string"
            },
            {
              "id": "4869bd92-11cf-49d7-88d2-58c2e7427adf",
              "name": "contentHint",
              "value": "={{ $('Get Document URL4').item.json.contentHint }}",
              "type": "string"
            },
            {
              "id": "1ddde114-bfd9-4ba6-bef2-c23c2f3c2721",
              "name": "isSingleUseCase",
              "value": "={{ $('Get Document URL4').item.json.isSingleUseCase }}",
              "type": "string"
            },
            {
              "id": "8e22c109-c631-4cb7-8390-702ff9b91af0",
              "name": "shouldProcess",
              "value": "={{ $('Get Document URL4').item.json.shouldProcess }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -48,
        1008
      ],
      "id": "0be418b7-fea1-40f2-8122-9c7e533dd025",
      "name": "Set Doc Id1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -368,
        1296
      ],
      "id": "c3066b5c-5292-4055-b798-063f55c73298",
      "name": "Merge Reference URL1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        480,
        1280
      ],
      "id": "99aa27fd-28fa-4127-bb4a-86cf32b8d7ac",
      "name": "Merge All Data1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1328,
        1264
      ],
      "id": "13c06328-1067-48c8-b6c4-5b895d7945c0",
      "name": "Update URLs to scrape sheet2"
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1663435215,
          "mode": "list",
          "cachedResultName": "Copy of Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=1663435215"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Generated Output": "Yes",
            "Document ID": "={{ $json.documentId }}"
          },
          "matchingColumns": [
            "Document ID"
          ],
          "schema": [
            {
              "id": "URL",
              "displayName": "URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Title",
              "displayName": "Title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Document ID",
              "displayName": "Document ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Document URL",
              "displayName": "Document URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is Scraped",
              "displayName": "Is Scraped",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is deleted",
              "displayName": "Is deleted",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Generated Output",
              "displayName": "Generated Output",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        1728,
        1264
      ],
      "id": "5bf36637-2fab-4489-8815-3988da9bc805",
      "name": "Update URLs to scrape sheet3",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Robust Flatten Output for updated schema\n// - Parses message (array/object/string, fenced/quoted) into array\n// - Normalizes to new mandatory keys\n// - Enforces Companies_Involved (\"\" if absent) and Other_References (array->semicolon string)\nconst REQUIRED_KEYS = [\n  \"Industry\",\"Subindustry\",\"Business_Function\",\"Business_Capability\",\n  \"Stakeholder_Or_User\",\"Companies_Involved\",\"Title_Of_AI_Use_Case\",\"Description\",\"Impact\",\n  \"Action_Implementation_Plan\",\"Expected_Outcomes_And_Results\",\"Datasets\",\n  \"AI_Capabilities_And_Tech\",\"Digital_Platforms_And_Tools_And_Models\",\n  \"AI_Algo_And_Frameworks\",\"Other_References\"\n];\n\nconst toStr = v => (v == null ? \"\" : String(v));\nconst isObj = v => v && typeof v === \"object\" && !Array.isArray(v);\n\nfunction cleanMessageString(s) {\n  if (!s) return \"\";\n  let str = String(s).trim();\n  // strip leading tokens and fenced code\n  str = str.replace(/^\\s*json\\s*/i, \"\").trim();\n  str = str.replace(/``````/g, \"\").trim();\n  // remove leading/trailing markdown noise\n  str = str.replace(/^\\s*Output:\\s*/i, \"\").trim();\n  return str;\n}\n\nfunction tryParseJson(s) {\n  try { return JSON.parse(s); } catch { return null; }\n}\n\n// Extract top-level {...} objects even if not inside an array\nfunction extractObjectsFromString(s) {\n  const objs = [];\n  let depth = 0, start = -1;\n  for (let i = 0; i < s.length; i++) {\n    const ch = s[i];\n    if (ch === \"{\") { if (depth === 0) start = i; depth++; }\n    else if (ch === \"}\") {\n      depth--;\n      if (depth === 0 && start !== -1) {\n        objs.push(s.slice(start, i + 1));\n        start = -1;\n      }\n    }\n  }\n  return objs;\n}\n\nfunction parseToArray(raw) {\n  if (raw == null) return null;\n  if (Array.isArray(raw)) return raw.slice();\n  if (isObj(raw)) return [raw];\n\n  let s = cleanMessageString(String(raw));\n\n  // Unquote double-encoded JSON\n  if ((s.startsWith('\"') && s.endsWith('\"')) || (s.startsWith(\"'\") && s.endsWith(\"'\"))) {\n    const unq = tryParseJson(s);\n    if (unq != null) {\n      if (Array.isArray(unq)) return unq;\n      if (isObj(unq)) return [unq];\n      if (typeof unq === \"string\") s = unq.trim();\n    }\n  }\n\n  // Direct parse\n  let p = tryParseJson(s);\n  if (p != null) return Array.isArray(p) ? p : [p];\n\n  // Parse first [...] slice\n  const lb = s.indexOf(\"[\"); const rb = s.lastIndexOf(\"]\");\n  if (lb !== -1 && rb !== -1 && rb > lb) {\n    const slice = s.slice(lb, rb + 1);\n    p = tryParseJson(slice);\n    if (p != null) return Array.isArray(p) ? p : [p];\n  }\n\n  // Parse top-level {...} blocks\n  const objs = extractObjectsFromString(s).map(tryParseJson).filter(o => isObj(o));\n  if (objs.length > 0) return objs;\n\n  return null;\n}\n\n// Merge legacy keys into new schema keys\nfunction harmonizeKeys(obj) {\n  const o = { ...obj };\n  // Legacy fields -> new fields\n  if (o.Digital_Platforms_And_Tools && !o.Digital_Platforms_And_Tools_And_Models) {\n    o.Digital_Platforms_And_Tools_And_Models = o.Digital_Platforms_And_Tools;\n  }\n  if (o.Tools_And_Models && !o.Digital_Platforms_And_Tools_And_Models) {\n    o.Digital_Platforms_And_Tools_And_Models = o.Tools_And_Models;\n  }\n  if (o[\"Other References\"] && !o.Other_References) {\n    o.Other_References = o[\"Other References\"];\n  }\n  if (o.OtherReferences && !o.Other_References) {\n    o.Other_References = o.OtherReferences;\n  }\n  return o;\n}\n\n// Convert arrays to semicolon strings; objects to JSON strings; scalars to trimmed strings\nfunction normalizeFieldValues(obj) {\n  const normalized = {};\n  for (const key of Object.keys(obj)) {\n    let v = obj[key];\n    if (Array.isArray(v)) {\n      normalized[key] = v.map(x => toStr(x).trim()).filter(Boolean).join(\"; \");\n    } else if (isObj(v)) {\n      try { normalized[key] = JSON.stringify(v); } catch { normalized[key] = toStr(v); }\n    } else {\n      normalized[key] = toStr(v).trim();\n    }\n  }\n  // Companies_Involved must exist: empty string if absent\n  if (!Object.prototype.hasOwnProperty.call(normalized, \"Companies_Involved\") || normalized.Companies_Involved == null) {\n    normalized.Companies_Involved = \"\";\n  }\n  // Ensure all REQUIRED_KEYS exist\n  for (const k of REQUIRED_KEYS) {\n    if (!Object.prototype.hasOwnProperty.call(normalized, k)) normalized[k] = \"\";\n  }\n  return normalized;\n}\n\nconst results = [];\nfor (const item of $input.all()) {\n  const chunkIndex = item.json?.chunk_index ?? item.json?._chunk_index ?? null;\n  const documentId = item.json?.documentId ?? item.json?._document_id ?? null;\n  const chunkContent = item.json?.content ?? item.json?._chunk_content ?? \"\";\n  const raw = item.json?.message ?? \"\";\n\n  const arr = parseToArray(raw);\n  if (!arr) {\n    console.log(\"⚠️ Flatten: could not parse message for chunk_index:\", chunkIndex);\n    results.push({\n      json: {\n        _chunk_index: chunkIndex,\n        _documentId: documentId,\n        _chunk_content: toStr(chunkContent),\n        _flag_parse_failed: true,\n        message: raw\n      }\n    });\n    continue;\n  }\n\n  for (const obj of arr) {\n    const harmonized = harmonizeKeys(obj);\n    const normalized = normalizeFieldValues(harmonized);\n\n    const missing = REQUIRED_KEYS.filter(k => !normalized[k] || normalized[k].trim() === \"\");\n    if (missing.length > 0) {\n      normalized._flag_missing_keys = true;\n      normalized._missing_keys = missing;\n      console.log(`⚠️ Flatten: missing keys for chunk ${chunkIndex}:`, missing);\n    }\n\n    results.push({\n      json: {\n        ...normalized,\n        _chunk_index: chunkIndex,\n        _documentId: documentId,\n        _chunk_content: toStr(chunkContent)\n      }\n    });\n  }\n}\nconsole.log(`Flattened ${results.length} items`);\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        848,
        1008
      ],
      "id": "7dd8051e-2f5a-4475-9d55-110731adca8e",
      "name": "Flatten Output1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "model": "sonar",
        "messages": {
          "message": [
            {
              "content": "=You are an extraction engine that converts filteredContent into a single JSON array of AI use cases. Operate only on spans present in filteredContent.\n\nGrounding and scope\n\nSpan-only: Extract only what explicitly appears in filteredContent; never invent or generalize beyond the text. If uncertain, exclude.\n\nExhaustive coverage: Process every heading block in order and extract all valid atoms inside each block before moving on.\n\nTitle anchoring: Copy titles verbatim from the atom span. If none, compose “<NearestHeading> — <first 4–8 words>”.\n\nIgnore navigation/marketing/link lists unless they contain a valid atom span.\n\nAtomic detection (must be visible in text)\n\nBullets/ordered: “- ”, “* ”, “– ”, “— ”, “1. ”, “2. ”, “A. ”, “B. ”\n\nBold-labeled: “Title: …”\n\nStandalone titled sentence at paragraph start: “Title: …”\n\nComplete “Opportunity / Solution / Outcome” triplet under a heading = exactly one atom\n\nDo not merge items; do not split one item. Strict parity: detected atoms = JSON objects.\n\nDeterministic procedure\n\nSegment filteredContent by headings (## or ###) in source order.\n\nWithin each segment, treat separators (“* * *”, “=”, blank lines) as boundaries and detect atoms strictly by the allowed shapes above.\n\nBuild an ordered list of all atoms across all segments. For each atom, set Industry from its nearest heading; stop inheritance at the next heading of same/higher level.\n\nFill the schema from that atom’s span only, with conservative enrichment; if a field cannot be safely inferred from the span, set \"\".\n\nOutput one JSON array whose length equals the total atom count. No extra text.\n\nSchema per object (all keys required)\n\nIndustry (1–2)\n\nSubindustry (≤3)\n\nBusiness_Function (2–3)\n\nBusiness_Capability (2–3)\n\nStakeholder_Or_User (2–3)\n\nAgent_Type (Customer | Employee | Code | Data | Creative | Security | \"\")\n\nCompanies_Involved (explicit names ≤5, else \"\")\n\nTitle_Of_AI_Use_Case\n\nDescription (70–150 words; faithful only to the atom span)\n\nImpact (1–2 lines; non-empty)\n\nAction_Implementation_Plan (exactly 4 numbered steps)\n\nExpected_Outcomes_And_Results (1–2 lines; non-empty)\n\nDatasets (conservatively inferred from the same span)\n\nAI_Capabilities_And_Tech (≥2; no duplicates)\n\nDigital_Platforms_And_Tools_And_Models (5–10 unique; domain-aligned; no duplicates)\n\nAI_Algo_And_Frameworks (4–6 advanced, diverse, context-aligned; e.g., Transformers, Graph Neural Networks, GANs, Variational Autoencoders, Diffusion Models, Reinforcement Learning, Gradient Boosted Trees; no duplicates)\n\nOther_References (≥2 valid URLs; prefer links in or clearly tied to the atom span)\n\nAbsolutes\n\nIf shouldProcess = false → return []\n\nIf isSingleUseCase = true OR determinedAs = \"single\" → return exactly one object from the first valid atom under the first heading\n\nElse process all headings and all atoms exhaustively with strict parity\n\nOutput only one valid JSON array; no commentary",
              "role": "system"
            },
            {
              "content": "=Use only the variables and the filteredContent below to extract all use cases strictly from the text, across all headings.\n\n{{ $json.filteredContent }}\n\nSignals\n\nisSingleUseCase: {{ $json.isSingleUseCase }}\n\ndeterminedAs: {{ $json.determinedAs }}\n\nshouldProcess: {{ $json.shouldProcess }}\n\ncontentHint: {{ $json.contentHint }}\n\nInstructions\n\nIf shouldProcess = \"false\" → return []\n\nIf isSingleUseCase = \"true\" OR determinedAs = \"single\" → return exactly 1 object from the first valid atom under the first heading\n\nOtherwise:\n\nSegment by headings (##/###) in order and fully extract all atoms within each segment before moving on\n\nDetect atoms only if they match one of:\n\nBullets/ordered items\n\n“Title: …”\n\n“Title: …” at paragraph start\n\nA complete “Opportunity / Solution / Outcome” triplet\n\nTreat separators (“* * *”, “=”, blank lines) as boundaries\n\nCopy titles verbatim; if none, compose “<NearestHeading> — <first 4–8 words>”\n\nEnsure JSON array length equals the total number of detected atoms across all headings\n\nFor each object, fill every schema field. If a value cannot be safely inferred from the atom span, set \"\". For AI_Algo_And_Frameworks, always include 4–6 advanced, diverse, context‑aligned items.\n\nOutput\nReturn only a single valid JSON array. No extra text."
            }
          ]
        },
        "simplify": true,
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexity",
      "typeVersion": 1,
      "position": [
        416,
        1008
      ],
      "id": "c24ea29e-ad17-4d18-8f4e-c0b34f47ea38",
      "name": "LLM1",
      "credentials": {
        "perplexityApi": {
          "id": "2X923WJEbWR6QPD5",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Safe input to string\nconst raw = $json.content ?? \"\";\nconst text = typeof raw === \"string\" ? raw : String(raw);\n\n// Normalize line endings to \\n for consistent searching\nconst norm = text.replace(/\\r\\n?/g, \"\\n\");\n\n// Build case-insensitive, full-line marker regexes\n// We anchor to line starts/ends to avoid matching inline occurrences.\nconst startRe = /^[ \\t]*===\\s*USE CASES START BELOW\\s*===[ \\t]*$/im;\nconst endRe   = /^[ \\t]*===\\s*REFERENCES\\s*\\/\\s*SOURCES\\s*===[ \\t]*$/im;\n\n// Find start marker line match\nconst startMatch = norm.match(startRe);\n\nlet extracted = \"\";\nif (startMatch) {\n  // startMatch.index gives start of line; compute end-of-line to begin content after the start marker line\n  const startLineStart = startMatch.index;\n  const startLineEnd = startLineStart + startMatch.length;\n  // Move to after the newline following the start line (if present)\n  const afterStartNewlineIdx = norm.indexOf(\"\\n\", startLineEnd);\n  const contentStart = afterStartNewlineIdx === -1 ? startLineEnd : afterStartNewlineIdx + 1;\n\n  // Search for end marker only after contentStart\n  endRe.lastIndex = contentStart; // ensure search starts after start\n  const endMatch = endRe.exec(norm);\n\n  const contentEnd = endMatch ? endMatch.index : norm.length;\n\n  // Slice original text using equivalent indices in the normalized buffer.\n  // Because we only normalized CRLF->LF, indices still align with norm’s positions.\n  extracted = norm.slice(contentStart, contentEnd).trim();\n}\n\n// Carry forward values\nconst isSingleUseCase = $json.isSingleUseCase ?? null;\nconst determinedAs = $json.determinedAs ?? \"unknown\";\nconst shouldProcess = $json.shouldProcess ?? true;\nconst contentHint = $json.contentHint ?? \"\";\n\n// Keep UI preview bounded, but do NOT affect filteredContent\nconst RAW_PREVIEW_LIMIT = 1000;\nconst rawContentPreview = norm.length > RAW_PREVIEW_LIMIT ? norm.slice(0, RAW_PREVIEW_LIMIT) : norm;\n\nreturn [{\n  json: {\n    filteredContent: extracted, // strictly between the two === ... === markers\n    rawContent: rawContentPreview,\n    rawContentTruncated: norm.length > RAW_PREVIEW_LIMIT,\n    isSingleUseCase,\n    determinedAs,\n    shouldProcess,\n    contentHint\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        1008
      ],
      "id": "38d3d071-5575-4978-bf8f-a0eb670f7ff1",
      "name": "Passing Use Cases only from Content1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "db8cc92c-96d3-4955-a9cf-b958b3647984",
              "name": "URL",
              "value": "={{ $json.data.metadata.url }}",
              "type": "string"
            },
            {
              "id": "03b76a3d-2d10-4dc5-ad5b-c5f737db236c",
              "name": "Title",
              "value": "={{ $json.data.metadata.title }}",
              "type": "string"
            },
            {
              "id": "3bd6afdf-10fc-4ce9-a217-236207ae70d8",
              "name": "Content",
              "value": "={{ $json.data.markdown }}",
              "type": "string"
            },
            {
              "id": "13853381-3037-4689-9a26-78f32cc5b2fa",
              "name": "Document ID",
              "value": "={{ $('Get URLs to scrape1').item.json['Document ID'] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        672,
        384
      ],
      "id": "59235776-737e-4de3-82c5-1801f10e3075",
      "name": "Get content1"
    },
    {
      "parameters": {
        "folderId": "1cU0R27x063BPzfi7dA9pQK2HQ9MSCUQ5",
        "title": "={{ $json.Title }}"
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        2048,
        464
      ],
      "id": "4b444c98-2bab-41ff-a586-0ed099505be6",
      "name": "Create Google Docs1",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        0,
        0
      ],
      "id": "20fcfde9-70a7-4596-a5bf-e287b510ca6d",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "operation": "update",
        "documentURL": "={{ $json.documentId }}",
        "actionsUi": {
          "actionFields": [
            {
              "action": "replaceAll",
              "text": "={{ $json.content }}",
              "replaceText": "={{ $('If7').item.json.cleanedOutput }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        2320,
        288
      ],
      "id": "fde89b8b-5a45-4653-b1e3-1b1bf5a82e6c",
      "name": "Update Text to Google Docs1",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentURL": "={{ $json.id }}",
        "actionsUi": {
          "actionFields": [
            {
              "action": "insert",
              "text": "={{ $('If7').item.json.cleanedOutput }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        2336,
        464
      ],
      "id": "c5ba512c-07e3-40db-aa67-2d6a0f90be41",
      "name": "Save Text to Google Docs",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "documentURL": "={{ $json.DocumentID }}"
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        2032,
        288
      ],
      "id": "8f7de2f7-a60f-4dec-8efd-8d6aacbece0a",
      "name": "Get Google Docs1",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "Uo1hl0kTXPVPhAqa",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1663435215,
          "mode": "list",
          "cachedResultName": "Copy of Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=1663435215"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Document ID": "={{ $json.documentId }}",
            "Document URL": "=https://docs.google.com/document/d/{{ $json.documentId }}",
            "Is Scraped": "Yes",
            "URL": "={{ $('Code3').item.json.URL }}",
            "Title": "={{ $('Code3').item.json.Title }}",
            "contentHint": "={{ $('Code3').item.json.contentHint }}",
            "isSingleUseCase": "={{ $('Code3').item.json.isSingleUseCase }}",
            "determinedAs": "={{ $('Code3').item.json.determinedAs }}",
            "shouldProcess": "={{ $('Code3').item.json.shouldProcess }}"
          },
          "matchingColumns": [
            "URL"
          ],
          "schema": [
            {
              "id": "URL",
              "displayName": "URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Title",
              "displayName": "Title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Document ID",
              "displayName": "Document ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Document URL",
              "displayName": "Document URL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is Scraped",
              "displayName": "Is Scraped",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Is deleted",
              "displayName": "Is deleted",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "Generated Output",
              "displayName": "Generated Output",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "isSingleUseCase",
              "displayName": "isSingleUseCase",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "determinedAs",
              "displayName": "determinedAs",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "shouldProcess",
              "displayName": "shouldProcess",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "contentHint",
              "displayName": "contentHint",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "row_number",
              "displayName": "row_number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "readOnly": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        2592,
        384
      ],
      "id": "70f8b5a2-5e0b-4df1-b4e7-f68ad0d342de",
      "name": "Update Google Sheets2",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "amount": 10
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2784,
        384
      ],
      "id": "e441256a-bcb4-47cd-a7bb-d11072cc3072",
      "name": "Wait1",
      "webhookId": "90d20a5b-3453-4d82-af3f-b589370a7015"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo",
          "mode": "list",
          "cachedResultName": "URLs to scrape",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1663435215,
          "mode": "list",
          "cachedResultName": "Copy of Data",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1IOnSwrDqhgo5nTvl0F0vyJmbI2UdVtFawPgBsSb2FZo/edit#gid=1663435215"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        -176,
        400
      ],
      "id": "27add737-be8a-412e-9a0c-451dc222c120",
      "name": "Get URLs to scrape1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UXBOTM3lVKiQ3txI",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "scrape",
        "url": "={{ $json.URL }}",
        "scrapeOptions": {
          "options": {
            "formats": {
              "format": [
                {}
              ]
            },
            "excludeTags": {
              "items": [
                {
                  "tag": "audio, figure, figcaption, button, form, input, textarea, select, label, script, style, link"
                },
                {
                  "tag": "img"
                },
                {
                  "tag": "footer"
                },
                {
                  "tag": "noscript"
                },
                {
                  "tag": "iframe"
                },
                {
                  "tag": "header"
                },
                {
                  "tag": "nav"
                },
                {
                  "tag": "aside"
                },
                {
                  "tag": "svg"
                },
                {
                  "tag": "video"
                }
              ]
            },
            "headers": {}
          }
        },
        "requestOptions": {}
      },
      "type": "@mendable/n8n-nodes-firecrawl.firecrawl",
      "typeVersion": 1,
      "position": [
        464,
        384
      ],
      "id": "abd06e2e-9c0b-4c64-b2aa-f4d404f97d2b",
      "name": "Scrape a url and get its content",
      "credentials": {
        "firecrawlApi": {
          "id": "ogqoeHzW3hEaFFhK",
          "name": "Firecrawl account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "5ac134b7-1d5a-45ad-81c9-b469a0d0e8a6",
              "leftValue": "={{ $json.DocumentID }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1808,
        384
      ],
      "id": "8a306011-c561-4fe3-a3ca-89d4bfdeebe4",
      "name": "If7"
    },
    {
      "parameters": {
        "content": "## Scraping URL with FireCrawl & save to Google Sheets & option to re-scrape_v3",
        "height": 416,
        "width": 3408
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -416,
        272
      ],
      "id": "bc947304-53d7-4b7d-970f-80c6725de40d",
      "name": "Sticky Note12"
    },
    {
      "parameters": {
        "model": "sonar",
        "messages": {
          "message": [
            {
              "content": "=Role: strict line-by-line classifier and formatter. Do not shorten, paraphrase, or invent wording — only move raw input lines into exactly three sections, preserving original line breaks and Markdown formatting.\n\nOutput order (always exactly this):\n=== PARAGRAPHS / CONTEXT ===\n=== USE CASES START BELOW ===\n=== REFERENCES / SOURCES ===\n\nDefinitions:\n\nPARAGRAPHS: Background, intros, general info, analysis, surveys/methodology, definitions, marketing blurbs, section headings not describing an application, author bios, newsletter prompts, “More from this author,” sponsored blurbs, event promos, careers, awards, and generic statements about AI benefits. Keep them verbatim and in order.\n\nUSE CASES: Only lines that describe applications, implementations, deployments, examples, solutions, scenarios, partnerships, customer stories, adoption, named companies tied to applications, tools/technologies used, or “how it is applied.” Copy sentences exactly.\n\nREFERENCES: Any line that contains a URL/link or link-like token, including http, https, www., or a domain/file ending such as .com, .org, .net, .io, .ai, .co, .in, .html, .htm, .php, .aspx, .pdf; also “Read more,” “Learn more,” “Subscribe,” citations, or link-rich lists. Entire such lines go only here. Non-negotiable.\n\nUse-case block detection:\n\nBlock starters: treat these as the start of a USE CASES block and route them and subsequent related items to USE CASES unless a clear non-use-case heading interrupts:\n\nLines starting with “Use case”, “Use cases”, “Case study/ies”, “Examples”, “Customer stories”, “Applications”, “Implementations”, “Scenarios” (case-insensitive).\n\nNumbered or bulleted markers followed by an applied topic, e.g., “1.”, “1)”, “(1)”, “I.”, “A)”, “- ”, “- ”, “— ”, when the text describes how AI is used or names a company/tool/solution.\n\nMarkdown headings that enumerate applied topics, e.g., “## 1. …”, “### Use cases”, or “## Predictive maintenance” followed by deployments or named companies/tools.\n\nBlock continuation: once a use-case block starts, keep subsequent lines in USE CASES until:\n\nA new top-level or peer heading unrelated to applications appears (e.g., “Feature”, “Subscribe”, “Author”, “More from this author”), then switch back to PARAGRAPHS; or\n\nAn explicit “References/Read more/Subscribe/Sponsored/Links” region appears (send those lines to REFERENCES); or\n\nA new use-case block starter appears (continue in USE CASES).\n\nInterleaved context: if a clearly non-applied paragraph appears inside a use-case list (e.g., survey methodology or generic benefits), place only that line in PARAGRAPHS, but do not break the ongoing USE CASES block for the following items.\n\nGlobal rules:\n\nNever summarize, compress, or reword; keep names, numbers, and technical terms intact.\n\nPreserve original Markdown and line order within each section.\n\nSingle use case page: if explicitly stated by the user prompt, put all non-link lines in USE CASES; still route link-containing lines to REFERENCES.\n\nIf a section would be empty, include its heading and write “None”.\n\nExclusions from USE CASES: introductions, analysis, survey descriptions, list headings that don’t describe applications, generic benefits, author bios, newsletter signup text, sponsored/link blocks, event promos, careers.\n\nPriority for ambiguous lines:\n\nLinks → REFERENCES; lines inside a detected use-case block → USE CASES; otherwise → PARAGRAPHS.\n\nMandatory self-check before final output:\n\nSweep USE CASES and PARAGRAPHS; if any line contains http/https/www or ends with a domain/file pattern above, move that entire line to REFERENCES.\n\nEnsure each link-like line appears only once under REFERENCES; remove duplicates elsewhere.\n\nVerify that numbered/bulleted items under a use-case heading are in USE CASES; if any are not, move them into USE CASES as a contiguous group until the next non-use-case heading.\n\nOutput only the three sections in the required order; no extra commentary.\n\nFew-shot anchors (do not generalize wording; follow behavior):\nExample A\nInput lines:\n\n“## Use cases”\n\n“1. Predictive maintenance — GE analyzes engine data…”\n\n“2. Customer service — Lufthansa scaled digital support…”\n\n“Subscribe to our newsletter”\nBehavior:\n\nLines 1–3 → USE CASES; “Subscribe to our newsletter” → REFERENCES if it contains a link, otherwise PARAGRAPHS.\n\nExample B\nInput lines:\n\n“From chatbots to predictive maintenance…”\n\n“## 1. Cloud pricing optimization”\n\n“Organizations use AI to reduce cloud costs…”\n\n“## 2. Predictive maintenance”\n\n“GE analyzes engine data…”\nBehavior:\n\nIntro → PARAGRAPHS; “## 1…” and following descriptive line → USE CASES; “## 2…” and following line → USE CASES.",
              "role": "system"
            },
            {
              "content": "=Reorganize the following content into the 3-section format defined by your system rules. Do not change, shorten, or rephrase any text. Classify line-by-line and preserve original formatting.\n\nSource URL: {{ $json.URL }}\nTitle: {{ $json.Title }}\nContent Type Hint: {{ $json.contentHint }}\nBatch Info: {{ $json.BatchIndex }}/{{ $json.TotalBatches }}\n\nContent:\n{{ $json.Content }}\n\nProcessing directive:\n{{ $json.isSingleUseCase\n? \"This is part of a SINGLE use case page. Put all non-link lines in USE CASES. Any line containing a URL goes to REFERENCES.\"\n: \"Move only application/implementation lines to USE CASES; keep introductions, analysis, survey context, headings, author bios, newsletter/sponsored blocks, and general descriptions in PARAGRAPHS. Any line containing a URL must go to REFERENCES.\" }}\n\nHard constraints to enforce before returning:\n\nIf any line in USE CASES or PARAGRAPHS contains http, https, www., or ends with .com/.org/.net/.io/.ai/.co/.in/.html/.htm/.php/.aspx/.pdf, move that entire line to REFERENCES.\n\nDetect use-case block starters (e.g., lines beginning with “Use case…”, numbered/lettered items like “1.”, “1)”, “(1)”, “A)”, or headings like “## 1. …”) and keep subsequent list items in USE CASES until a non-use-case heading appears.\n\nDo not leave any link-containing lines outside REFERENCES. If duplicates exist, keep only one under REFERENCES.\n\nConflict resolution priority:\n\nLinks → REFERENCES; 2) Lines inside a detected use-case block → USE CASES; 3) Otherwise → PARAGRAPHS.\n\nReturn only:\n=== PARAGRAPHS / CONTEXT ===\n…content…\n=== USE CASES START BELOW ===\n…content…\n=== REFERENCES / SOURCES ===\n…content…"
            }
          ]
        },
        "simplify": true,
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexity",
      "typeVersion": 1,
      "position": [
        1040,
        384
      ],
      "id": "3115a76f-8d02-4cc4-9875-b3aaea544648",
      "name": "Get Structured Output1",
      "credentials": {
        "perplexityApi": {
          "id": "2X923WJEbWR6QPD5",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "1bcf4242-d114-471d-b842-2315e847de82",
              "leftValue": "={{ $json['Is Scraped'] }}",
              "rightValue": "No",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        32,
        400
      ],
      "id": "d533f28c-8b21-4b8a-9424-9c620205471d",
      "name": "If9"
    },
    {
      "parameters": {
        "jsCode": "// Universal Content Analyzer for n8n - With Paragraph-Aware Batching\n\nconst content = $json.Content || \"\";\nconst title = $json.Title || \"\";\nconst url = $json.URL || \"\";\n\n// === Clean content ===\n// Normalize whitespace but preserve paragraph breaks\nconst cleanedContent = content\n  .replace(/\\r\\n/g, \"\\n\")     // normalize line endings\n  .replace(/[ \\t]+/g, \" \")    // collapse spaces/tabs\n  .replace(/\\n{2,}/g, \"\\n\\n\") // keep max one empty line\n  .trim();\n\n// === Utility: Split text into batches by paragraph boundaries ===\nfunction splitByParagraphs(text, maxChars = 12000) {\n  const paragraphs = text.split(/\\n+/); // split by line breaks\n  const batches = [];\n  let currentBatch = \"\";\n\n  for (const p of paragraphs) {\n    // If adding this paragraph would exceed maxChars, start a new batch\n    if ((currentBatch + p).length > maxChars) {\n      if (currentBatch.trim()) {\n        batches.push(currentBatch.trim());\n      }\n      currentBatch = \"\";\n    }\n    currentBatch += p + \"\\n\";\n  }\n\n  if (currentBatch.trim()) {\n    batches.push(currentBatch.trim());\n  }\n\n  return batches;\n}\n\n// === Use case type detection ===\nfunction detectUseCaseCount(text, pageTitle, pageUrl) {\n  const combined = (text + \" \" + pageTitle).toLowerCase();\n\n  const strongSinglePatterns = [\n    /case study/i,\n    /success story/i,\n    /customer story/i,\n    /customer spotlight/i,\n    /press release/i,\n    /announcement/i,\n    /announces/i,\n    /partners with/i,\n    /collaborates with/i,\n    /joins forces with/i,\n    /teams up with/i,\n    /implements .+ solution/i,\n    /deploys .+ platform/i,\n    /migrates to/i,\n    /selects .+ (for|to)/i,\n    /chooses .+ (for|to)/i,\n  ];\n\n  const multiplePatterns = [\n    /\\b\\d+\\s+(use cases?|applications?|examples?|ways|scenarios?)\\b/i,\n    /\\b(top|best|key)\\s+\\d+\\s+/i,\n    /(?:^|\\n)\\d+[\\.\\)]\\s+.+(?:\\n\\d+[\\.\\)]\\s+.+){1,}/m,\n    /(?:^|\\n)[a-zA-Z][\\.\\)]\\s+.+(?:\\n[a-zA-Z][\\.\\)]\\s+.+){1,}/m,\n    /(?:^|\\n)\\s*[-*•]\\s+.+(?:\\n\\s*[-*•]\\s+.+){1,}/m\n  ];\n\n  let forcedSingle = false;\n  let forcedMultiple = false;\n\n  if (pageUrl) {\n    const u = pageUrl.toLowerCase();\n    if (u.includes(\"case-study\") || u.includes(\"success-story\") || u.includes(\"customer-story\") || u.includes(\"press-release\")) {\n      forcedSingle = true;\n    }\n    if (u.includes(\"use-cases\") || u.includes(\"examples\") || u.includes(\"applications\")) {\n      forcedMultiple = true;\n    }\n  }\n\n  const matchedSingle = strongSinglePatterns.some(p => p.test(combined));\n  const matchedMultiple = multiplePatterns.some(p => p.test(text));\n\n  if (matchedSingle || forcedSingle) {\n    return { isSingleUseCase: true, contentHint: \"SINGLE_USE_CASE_PAGE\" };\n  }\n  if (matchedMultiple || forcedMultiple) {\n    return { isSingleUseCase: false, contentHint: \"MULTIPLE_USE_CASES_PAGE\" };\n  }\n\n  return { isSingleUseCase: true, contentHint: \"SINGLE_USE_CASE_PAGE\" };\n}\n\n// === Relevance check ===\nfunction isRelevantContent(text, title) {\n  const combined = (text + \" \" + title).toLowerCase();\n  const relevancePatterns = [\n    \"use case\", \"application\", \"implementation\", \"deployment\",\n    \"case study\", \"success story\", \"example\", \"scenario\",\n    \"solution\", \"transform\", \"ai\", \"ml\", \"artificial intelligence\",\n    \"automation\", \"cloud\", \"digital transformation\"\n  ];\n  return relevancePatterns.some(p => combined.includes(p));\n}\n\n// === Main Analysis ===\nconst analysis = detectUseCaseCount(cleanedContent, title, url);\nconst isRelevant = isRelevantContent(cleanedContent, title);\n\n// === Split into paragraph-aware batches ===\nconst batches = splitByParagraphs(cleanedContent, 12000);\n\nreturn batches.map((batch, i) => ({\n  URL: url,\n  Title: title,\n  BatchIndex: i + 1,\n  TotalBatches: batches.length,\n  Content: batch,\n  contentHint: analysis.contentHint,\n  isSingleUseCase: analysis.isSingleUseCase,\n  isRelevant: isRelevant,\n  debug: { \n    determinedAs: analysis.isSingleUseCase ? \"SINGLE\" : \"MULTIPLE\",\n    batchLength: batch.length \n  },\n  shouldProcess: isRelevant\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        384
      ],
      "id": "746b634e-991c-4540-8e4d-4ac82d9e30ec",
      "name": "Universal Content Analyzer1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "e97e6670-4c89-4c5e-8ad8-ab8d19e643de",
              "leftValue": "={{ $json.documentId }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1536,
        1264
      ],
      "id": "b19d61aa-ce32-439c-aa9c-a0372513cea1",
      "name": "If4"
    },
    {
      "parameters": {
        "jsCode": "// === Code3 Node (Final Cleaner with Flattened determinedAs) ===\n\nreturn {\n  json: {\n    Title: $json.Title || null,\n    DocumentID: $json.DocumentID || null,\n    URL: $json.URL || null,\n    contentHint: $json.contentHint || null,\n    isSingleUseCase: $json.isSingleUseCase ?? null,\n    isRelevant: $json.isRelevant ?? null,\n    shouldProcess: $json.shouldProcess ?? null,\n    determinedAs: $json.determinedAs || null,   // ✅ flatten at root\n    cleanedOutput: $json.FinalOutput || null,\n    }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        384
      ],
      "id": "f10580a9-cf63-4c81-8cb2-3fe86a33582b",
      "name": "Code3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        256,
        384
      ],
      "id": "529b2c77-d9fb-44a9-abbb-4668852ded82",
      "name": "Limit9"
    },
    {
      "parameters": {
        "jsCode": "// === Combine Node (3-Section Merger with Metadata, flattened determinedAs) ===\n\nconst groups = {};\n\nfor (const item of items) {\n  const key = item.json.GroupKey || \"default\";\n\n  // Safely pull metadata\n  const title = item.json.Title || item.json.title || null;\n  const docId = item.json[\"Document ID\"] || item.json.DocumentID || item.json.documentId || null;\n  const url = item.json.URL || item.json.url || null;\n  const contentHint = item.json.contentHint || null;\n  const isSingleUseCase = item.json.isSingleUseCase ?? null;\n  const isRelevant = item.json.isRelevant ?? null;\n  const shouldProcess = item.json.shouldProcess ?? null;\n  const determinedAs = item.json.debug?.determinedAs || null;\n\n  if (!groups[key]) {\n    groups[key] = {\n      paragraphs: [],\n      use_cases: [],\n      references: [],\n      debug: [],\n      Title: title,\n      DocumentID: docId,\n      URL: url,\n      contentHint,\n      isSingleUseCase,\n      isRelevant,\n      shouldProcess,\n      determinedAs   // ✅ flatten to root\n    };\n  }\n\n  // Each LLM batch output should already follow the 3-section format\n  const msg = item.json.message || \"\";\n\n  // Extract sections via regex\n  const paraMatch = msg.match(/=== PARAGRAPHS \\/ CONTEXT ===([\\s\\S]*?)(?=== USE CASES START BELOW ===)/);\n  const useCaseMatch = msg.match(/=== USE CASES START BELOW ===([\\s\\S]*?)(?=== REFERENCES \\/ SOURCES ===)/);\n  const refMatch = msg.match(/=== REFERENCES \\/ SOURCES ===([\\s\\S]*)/);\n\n  if (paraMatch && paraMatch[1].trim() && paraMatch[1].trim() !== \"None\") {\n    groups[key].paragraphs.push(paraMatch[1].trim());\n  }\n  if (useCaseMatch && useCaseMatch[1].trim() && useCaseMatch[1].trim() !== \"None\") {\n    groups[key].use_cases.push(useCaseMatch[1].trim());\n  }\n  if (refMatch && refMatch[1].trim() && refMatch[1].trim() !== \"None\") {\n    groups[key].references.push(refMatch[1].trim());\n  }\n\n  groups[key].debug.push({\n    index: item.json.BatchIndex,\n    rawLength: (item.json.Content || \"\").length\n  });\n\n  // ✅ If later items contain non-null metadata, prefer them\n  if (!groups[key].Title && title) groups[key].Title = title;\n  if (!groups[key].DocumentID && docId) groups[key].DocumentID = docId;\n  if (!groups[key].URL && url) groups[key].URL = url;\n  if (!groups[key].contentHint && contentHint) groups[key].contentHint = contentHint;\n  if (groups[key].isSingleUseCase === null && isSingleUseCase !== null) groups[key].isSingleUseCase = isSingleUseCase;\n  if (groups[key].isRelevant === null && isRelevant !== null) groups[key].isRelevant = isRelevant;\n  if (groups[key].shouldProcess === null && shouldProcess !== null) groups[key].shouldProcess = shouldProcess;\n  if (!groups[key].determinedAs && determinedAs) groups[key].determinedAs = determinedAs;\n}\n\n// Final combined output\nreturn Object.entries(groups).map(([key, group]) => {\n  // Deduplicate references\n  const dedupedRefs = [...new Set(group.references.join(\"\\n\").split(/\\n+/))].filter(r => r.trim());\n\n  return {\n    json: {\n      GroupKey: key,\n      Title: group.Title || null,\n      DocumentID: group.DocumentID || null,\n      URL: group.URL || null,\n      contentHint: group.contentHint || null,\n      isSingleUseCase: group.isSingleUseCase,\n      isRelevant: group.isRelevant,\n      shouldProcess: group.shouldProcess,\n      determinedAs: group.determinedAs || null,   // ✅ flattened\n      FinalOutput:\n        \"=== PARAGRAPHS / CONTEXT ===\\n\" +\n        (group.paragraphs.length ? group.paragraphs.join(\"\\n\\n\") : \"None\") +\n        \"\\n\\n=== USE CASES START BELOW ===\\n\" +\n        (group.use_cases.length ? group.use_cases.join(\"\\n\\n\") : \"None\") +\n        \"\\n\\n=== REFERENCES / SOURCES ===\\n\" +\n        (dedupedRefs.length ? dedupedRefs.join(\"\\n\") : \"None\"),\n      DebugInfo: group.debug\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        384
      ],
      "id": "afd8e08f-6023-4e23-a12b-b8e3904aebc4",
      "name": "Combine"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1248,
        384
      ],
      "id": "51d11087-ea50-46ae-9634-ff6f1b99998c",
      "name": "Merge"
    }
  ],
  "connections": {
    "Get Document URL4": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get document4": {
      "main": [
        [
          {
            "node": "Set Doc Id1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output4": {
      "main": [
        [
          {
            "node": "Store the Output4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store the Output4": {
      "main": [
        [
          {
            "node": "Limit8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get ID4": {
      "main": [
        [
          {
            "node": "Merge Reference URL1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [
          {
            "node": "Limit7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Id and URL3": {
      "main": [
        [
          {
            "node": "Merge All Data1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Limit7": {
      "main": [
        [
          {
            "node": "Merge Reference URL1",
            "type": "main",
            "index": 1
          },
          {
            "node": "Get document4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit8": {
      "main": [
        [
          {
            "node": "Update URLs to scrape sheet2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Final Deduplication": {
      "main": [
        [
          {
            "node": "Merge All Data1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler Node1": {
      "main": [
        [
          {
            "node": "Flatten Output1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Accumulator Node1": {
      "main": [
        [
          {
            "node": "Final Deduplication",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation1": {
      "main": [
        [
          {
            "node": "Accumulator Node1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Case Integrity Check1": {
      "main": [
        [
          {
            "node": "Validation1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Subindustry Enricher1": {
      "main": [
        [
          {
            "node": "Use Case Integrity Check1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Id and URL1": {
      "main": [
        [
          {
            "node": "Set Id and URL3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Doc Id1": {
      "main": [
        [
          {
            "node": "Update URLs to scrape sheet2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Passing Use Cases only from Content1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Reference URL1": {
      "main": [
        [
          {
            "node": "Get Id and URL1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Data1": {
      "main": [
        [
          {
            "node": "Structured Output4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update URLs to scrape sheet2": {
      "main": [
        [
          {
            "node": "If4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Flatten Output1": {
      "main": [
        [
          {
            "node": "Subindustry Enricher1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM1": {
      "main": [
        [
          {
            "node": "Error Handler Node1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Passing Use Cases only from Content1": {
      "main": [
        [
          {
            "node": "LLM1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get content1": {
      "main": [
        [
          {
            "node": "Universal Content Analyzer1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Create Google Docs1": {
      "main": [
        [
          {
            "node": "Save Text to Google Docs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Text to Google Docs1": {
      "main": [
        [
          {
            "node": "Update Google Sheets2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Text to Google Docs": {
      "main": [
        [
          {
            "node": "Update Google Sheets2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Google Docs1": {
      "main": [
        [
          {
            "node": "Update Text to Google Docs1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Google Sheets2": {
      "main": [
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get URLs to scrape1": {
      "main": [
        [
          {
            "node": "If9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape a url and get its content": {
      "main": [
        [
          {
            "node": "Get content1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If7": {
      "main": [
        [
          {
            "node": "Get Google Docs1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Google Docs1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Structured Output1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If9": {
      "main": [
        [
          {
            "node": "Limit9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Universal Content Analyzer1": {
      "main": [
        [
          {
            "node": "Get Structured Output1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "If4": {
      "main": [
        [
          {
            "node": "Update URLs to scrape sheet3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code3": {
      "main": [
        [
          {
            "node": "If7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit9": {
      "main": [
        [
          {
            "node": "Scrape a url and get its content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine": {
      "main": [
        [
          {
            "node": "Code3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Combine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "bfcd6787278013c4297eab9e02ba1b471bfeb33559859e03b602b2c606ee76d9"
  }
}
